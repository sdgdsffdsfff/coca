// Code generated from PythonParser.g4 by ANTLR 4.7.2. DO NOT EDIT.

package parser // PythonParser

import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 102, 979,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 3, 2, 3, 2, 3, 2, 5, 2, 128, 10, 2, 3,
	2, 3, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 5, 3, 137, 10, 3, 3, 4, 3, 4, 6,
	4, 141, 10, 4, 13, 4, 14, 4, 142, 3, 5, 3, 5, 7, 5, 147, 10, 5, 12, 5,
	14, 5, 150, 11, 5, 3, 6, 3, 6, 5, 6, 154, 10, 6, 3, 7, 3, 7, 3, 7, 3, 7,
	3, 7, 7, 7, 161, 10, 7, 12, 7, 14, 7, 164, 11, 7, 3, 7, 5, 7, 167, 10,
	7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 5, 7, 174, 10, 7, 3, 7, 5, 7, 177, 10,
	7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 5, 7, 186, 10, 7, 3, 7, 3,
	7, 3, 7, 3, 7, 6, 7, 192, 10, 7, 13, 7, 14, 7, 193, 3, 7, 5, 7, 197, 10,
	7, 3, 7, 5, 7, 200, 10, 7, 3, 7, 5, 7, 203, 10, 7, 3, 7, 5, 7, 206, 10,
	7, 3, 7, 3, 7, 3, 7, 3, 7, 7, 7, 212, 10, 7, 12, 7, 14, 7, 215, 11, 7,
	3, 7, 3, 7, 3, 7, 3, 7, 7, 7, 221, 10, 7, 12, 7, 14, 7, 224, 11, 7, 3,
	7, 3, 7, 5, 7, 228, 10, 7, 5, 7, 230, 10, 7, 3, 8, 3, 8, 3, 8, 3, 8, 6,
	8, 236, 10, 8, 13, 8, 14, 8, 237, 3, 8, 3, 8, 5, 8, 242, 10, 8, 3, 9, 3,
	9, 3, 9, 3, 9, 5, 9, 248, 10, 9, 3, 9, 5, 9, 251, 10, 9, 3, 9, 3, 9, 3,
	10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 11, 3, 11, 3, 11, 3, 11, 3, 12, 3, 12,
	3, 12, 3, 12, 3, 13, 3, 13, 3, 13, 5, 13, 271, 10, 13, 3, 14, 3, 14, 3,
	14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 5, 14,
	285, 10, 14, 5, 14, 287, 10, 14, 3, 14, 3, 14, 3, 14, 3, 15, 3, 15, 3,
	15, 3, 15, 5, 15, 296, 10, 15, 3, 15, 5, 15, 299, 10, 15, 3, 15, 3, 15,
	3, 15, 3, 16, 5, 16, 305, 10, 16, 3, 16, 3, 16, 3, 16, 3, 16, 5, 16, 311,
	10, 16, 3, 16, 3, 16, 3, 16, 5, 16, 316, 10, 16, 3, 16, 3, 16, 3, 16, 3,
	17, 3, 17, 3, 17, 5, 17, 324, 10, 17, 3, 17, 3, 17, 3, 17, 5, 17, 329,
	10, 17, 3, 17, 3, 17, 5, 17, 333, 10, 17, 3, 17, 5, 17, 336, 10, 17, 3,
	17, 5, 17, 339, 10, 17, 3, 17, 3, 17, 5, 17, 343, 10, 17, 5, 17, 345, 10,
	17, 3, 18, 3, 18, 3, 18, 3, 19, 3, 19, 3, 19, 3, 20, 3, 20, 3, 20, 7, 20,
	356, 10, 20, 12, 20, 14, 20, 359, 11, 20, 3, 21, 3, 21, 3, 21, 5, 21, 364,
	10, 21, 3, 21, 5, 21, 367, 10, 21, 3, 22, 3, 22, 3, 22, 5, 22, 372, 10,
	22, 3, 23, 3, 23, 3, 23, 7, 23, 377, 10, 23, 12, 23, 14, 23, 380, 11, 23,
	3, 23, 5, 23, 383, 10, 23, 3, 23, 3, 23, 3, 24, 3, 24, 5, 24, 389, 10,
	24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 7, 24, 396, 10, 24, 12, 24, 14,
	24, 399, 11, 24, 3, 24, 5, 24, 402, 10, 24, 3, 24, 3, 24, 3, 24, 3, 24,
	6, 24, 408, 10, 24, 13, 24, 14, 24, 409, 3, 24, 5, 24, 413, 10, 24, 5,
	24, 415, 10, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24,
	3, 24, 5, 24, 426, 10, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 5,
	24, 434, 10, 24, 5, 24, 436, 10, 24, 5, 24, 438, 10, 24, 3, 24, 3, 24,
	5, 24, 442, 10, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3,
	24, 3, 24, 3, 24, 3, 24, 3, 24, 7, 24, 456, 10, 24, 12, 24, 14, 24, 459,
	11, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 5, 24, 468, 10,
	24, 5, 24, 470, 10, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 5, 24,
	478, 10, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 7, 24, 485, 10, 24, 12,
	24, 14, 24, 488, 11, 24, 3, 24, 3, 24, 5, 24, 492, 10, 24, 3, 25, 7, 25,
	495, 10, 25, 12, 25, 14, 25, 498, 11, 25, 3, 25, 3, 25, 6, 25, 502, 10,
	25, 13, 25, 14, 25, 503, 5, 25, 506, 10, 25, 3, 26, 3, 26, 3, 26, 3, 26,
	3, 26, 3, 26, 5, 26, 514, 10, 26, 3, 27, 3, 27, 5, 27, 518, 10, 27, 3,
	27, 3, 27, 6, 27, 522, 10, 27, 13, 27, 14, 27, 523, 3, 27, 3, 27, 5, 27,
	528, 10, 27, 3, 27, 5, 27, 531, 10, 27, 3, 28, 3, 28, 3, 28, 3, 29, 3,
	29, 3, 29, 3, 29, 7, 29, 540, 10, 29, 12, 29, 14, 29, 543, 11, 29, 3, 29,
	3, 29, 5, 29, 547, 10, 29, 3, 29, 5, 29, 550, 10, 29, 3, 29, 3, 29, 3,
	29, 3, 29, 3, 29, 5, 29, 557, 10, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29,
	5, 29, 564, 10, 29, 5, 29, 566, 10, 29, 3, 30, 3, 30, 3, 30, 7, 30, 571,
	10, 30, 12, 30, 14, 30, 574, 11, 30, 3, 30, 5, 30, 577, 10, 30, 3, 31,
	3, 31, 3, 31, 7, 31, 582, 10, 31, 12, 31, 14, 31, 585, 11, 31, 3, 31, 5,
	31, 588, 10, 31, 3, 32, 3, 32, 3, 32, 5, 32, 593, 10, 32, 3, 33, 3, 33,
	3, 33, 7, 33, 598, 10, 33, 12, 33, 14, 33, 601, 11, 33, 3, 34, 3, 34, 3,
	34, 5, 34, 606, 10, 34, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 5, 35,
	614, 10, 35, 3, 35, 3, 35, 5, 35, 618, 10, 35, 3, 35, 3, 35, 5, 35, 622,
	10, 35, 3, 36, 3, 36, 3, 36, 5, 36, 627, 10, 36, 3, 36, 3, 36, 3, 36, 5,
	36, 632, 10, 36, 3, 36, 3, 36, 5, 36, 636, 10, 36, 3, 36, 5, 36, 639, 10,
	36, 3, 36, 5, 36, 642, 10, 36, 3, 36, 3, 36, 5, 36, 646, 10, 36, 5, 36,
	648, 10, 36, 3, 37, 3, 37, 3, 37, 7, 37, 653, 10, 37, 12, 37, 14, 37, 656,
	11, 37, 3, 38, 3, 38, 3, 38, 5, 38, 661, 10, 38, 3, 38, 5, 38, 664, 10,
	38, 3, 39, 3, 39, 3, 39, 3, 40, 3, 40, 3, 40, 3, 41, 3, 41, 3, 41, 3, 41,
	5, 41, 676, 10, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 7, 41, 684,
	10, 41, 12, 41, 14, 41, 687, 11, 41, 3, 42, 3, 42, 3, 42, 3, 42, 3, 42,
	3, 42, 3, 42, 3, 42, 3, 42, 3, 42, 3, 42, 3, 42, 5, 42, 701, 10, 42, 3,
	42, 3, 42, 3, 42, 5, 42, 706, 10, 42, 5, 42, 708, 10, 42, 3, 42, 7, 42,
	711, 10, 42, 12, 42, 14, 42, 714, 11, 42, 3, 43, 3, 43, 5, 43, 718, 10,
	43, 3, 43, 3, 43, 7, 43, 722, 10, 43, 12, 43, 14, 43, 725, 11, 43, 3, 43,
	3, 43, 5, 43, 729, 10, 43, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 3,
	43, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43,
	3, 43, 3, 43, 3, 43, 3, 43, 7, 43, 752, 10, 43, 12, 43, 14, 43, 755, 11,
	43, 3, 44, 3, 44, 3, 44, 5, 44, 760, 10, 44, 3, 44, 3, 44, 3, 44, 5, 44,
	765, 10, 44, 3, 44, 3, 44, 3, 44, 5, 44, 770, 10, 44, 3, 44, 3, 44, 3,
	44, 3, 44, 5, 44, 776, 10, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44,
	3, 44, 5, 44, 785, 10, 44, 3, 44, 3, 44, 3, 44, 6, 44, 790, 10, 44, 13,
	44, 14, 44, 791, 5, 44, 794, 10, 44, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45,
	3, 45, 5, 45, 802, 10, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3,
	45, 5, 45, 811, 10, 45, 7, 45, 813, 10, 45, 12, 45, 14, 45, 816, 11, 45,
	3, 45, 5, 45, 819, 10, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 5,
	45, 827, 10, 45, 3, 46, 3, 46, 5, 46, 831, 10, 46, 3, 46, 3, 46, 3, 46,
	3, 46, 5, 46, 837, 10, 46, 7, 46, 839, 10, 46, 12, 46, 14, 46, 842, 11,
	46, 3, 46, 5, 46, 845, 10, 46, 5, 46, 847, 10, 46, 3, 47, 3, 47, 3, 47,
	7, 47, 852, 10, 47, 12, 47, 14, 47, 855, 11, 47, 3, 47, 5, 47, 858, 10,
	47, 3, 48, 3, 48, 3, 48, 3, 48, 3, 48, 3, 48, 7, 48, 866, 10, 48, 12, 48,
	14, 48, 869, 11, 48, 3, 49, 3, 49, 3, 50, 3, 50, 3, 50, 5, 50, 876, 10,
	50, 3, 51, 3, 51, 3, 52, 3, 52, 5, 52, 882, 10, 52, 3, 53, 3, 53, 3, 53,
	5, 53, 887, 10, 53, 3, 54, 3, 54, 3, 54, 5, 54, 892, 10, 54, 3, 54, 5,
	54, 895, 10, 54, 3, 55, 3, 55, 5, 55, 899, 10, 55, 3, 55, 3, 55, 3, 55,
	3, 55, 3, 55, 5, 55, 906, 10, 55, 3, 56, 3, 56, 3, 56, 7, 56, 911, 10,
	56, 12, 56, 14, 56, 914, 11, 56, 3, 56, 5, 56, 917, 10, 56, 3, 57, 3, 57,
	3, 57, 3, 57, 5, 57, 923, 10, 57, 3, 57, 3, 57, 5, 57, 927, 10, 57, 3,
	58, 3, 58, 3, 58, 7, 58, 932, 10, 58, 12, 58, 14, 58, 935, 11, 58, 3, 58,
	5, 58, 938, 10, 58, 3, 59, 3, 59, 3, 59, 3, 59, 5, 59, 944, 10, 59, 3,
	59, 5, 59, 947, 10, 59, 5, 59, 949, 10, 59, 3, 59, 3, 59, 5, 59, 953, 10,
	59, 3, 59, 5, 59, 956, 10, 59, 5, 59, 958, 10, 59, 3, 60, 3, 60, 5, 60,
	962, 10, 60, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 5, 61, 969, 10, 61, 3,
	62, 3, 62, 3, 62, 3, 62, 5, 62, 975, 10, 62, 5, 62, 977, 10, 62, 3, 62,
	2, 6, 80, 82, 84, 94, 63, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26,
	28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62,
	64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98,
	100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 2, 12, 3, 3,
	5, 5, 3, 2, 43, 44, 3, 2, 72, 84, 4, 2, 57, 58, 62, 62, 5, 2, 46, 46, 59,
	61, 70, 70, 3, 2, 57, 58, 3, 2, 55, 56, 4, 2, 41, 42, 98, 98, 3, 2, 86,
	89, 4, 2, 46, 46, 50, 50, 2, 1118, 2, 127, 3, 2, 2, 2, 4, 136, 3, 2, 2,
	2, 6, 140, 3, 2, 2, 2, 8, 144, 3, 2, 2, 2, 10, 153, 3, 2, 2, 2, 12, 229,
	3, 2, 2, 2, 14, 241, 3, 2, 2, 2, 16, 243, 3, 2, 2, 2, 18, 254, 3, 2, 2,
	2, 20, 259, 3, 2, 2, 2, 22, 263, 3, 2, 2, 2, 24, 267, 3, 2, 2, 2, 26, 272,
	3, 2, 2, 2, 28, 291, 3, 2, 2, 2, 30, 304, 3, 2, 2, 2, 32, 344, 3, 2, 2,
	2, 34, 346, 3, 2, 2, 2, 36, 349, 3, 2, 2, 2, 38, 352, 3, 2, 2, 2, 40, 366,
	3, 2, 2, 2, 42, 368, 3, 2, 2, 2, 44, 373, 3, 2, 2, 2, 46, 491, 3, 2, 2,
	2, 48, 505, 3, 2, 2, 2, 50, 513, 3, 2, 2, 2, 52, 530, 3, 2, 2, 2, 54, 532,
	3, 2, 2, 2, 56, 565, 3, 2, 2, 2, 58, 567, 3, 2, 2, 2, 60, 578, 3, 2, 2,
	2, 62, 589, 3, 2, 2, 2, 64, 594, 3, 2, 2, 2, 66, 602, 3, 2, 2, 2, 68, 621,
	3, 2, 2, 2, 70, 647, 3, 2, 2, 2, 72, 649, 3, 2, 2, 2, 74, 663, 3, 2, 2,
	2, 76, 665, 3, 2, 2, 2, 78, 668, 3, 2, 2, 2, 80, 675, 3, 2, 2, 2, 82, 688,
	3, 2, 2, 2, 84, 728, 3, 2, 2, 2, 86, 793, 3, 2, 2, 2, 88, 826, 3, 2, 2,
	2, 90, 830, 3, 2, 2, 2, 92, 848, 3, 2, 2, 2, 94, 859, 3, 2, 2, 2, 96, 870,
	3, 2, 2, 2, 98, 875, 3, 2, 2, 2, 100, 877, 3, 2, 2, 2, 102, 879, 3, 2,
	2, 2, 104, 886, 3, 2, 2, 2, 106, 894, 3, 2, 2, 2, 108, 905, 3, 2, 2, 2,
	110, 907, 3, 2, 2, 2, 112, 926, 3, 2, 2, 2, 114, 928, 3, 2, 2, 2, 116,
	957, 3, 2, 2, 2, 118, 959, 3, 2, 2, 2, 120, 963, 3, 2, 2, 2, 122, 976,
	3, 2, 2, 2, 124, 128, 5, 4, 3, 2, 125, 128, 5, 6, 4, 2, 126, 128, 5, 8,
	5, 2, 127, 124, 3, 2, 2, 2, 127, 125, 3, 2, 2, 2, 127, 126, 3, 2, 2, 2,
	127, 128, 3, 2, 2, 2, 128, 129, 3, 2, 2, 2, 129, 130, 7, 2, 2, 3, 130,
	3, 3, 2, 2, 2, 131, 137, 7, 5, 2, 2, 132, 137, 5, 44, 23, 2, 133, 134,
	5, 12, 7, 2, 134, 135, 7, 5, 2, 2, 135, 137, 3, 2, 2, 2, 136, 131, 3, 2,
	2, 2, 136, 132, 3, 2, 2, 2, 136, 133, 3, 2, 2, 2, 137, 5, 3, 2, 2, 2, 138,
	141, 7, 5, 2, 2, 139, 141, 5, 10, 6, 2, 140, 138, 3, 2, 2, 2, 140, 139,
	3, 2, 2, 2, 141, 142, 3, 2, 2, 2, 142, 140, 3, 2, 2, 2, 142, 143, 3, 2,
	2, 2, 143, 7, 3, 2, 2, 2, 144, 148, 5, 92, 47, 2, 145, 147, 7, 5, 2, 2,
	146, 145, 3, 2, 2, 2, 147, 150, 3, 2, 2, 2, 148, 146, 3, 2, 2, 2, 148,
	149, 3, 2, 2, 2, 149, 9, 3, 2, 2, 2, 150, 148, 3, 2, 2, 2, 151, 154, 5,
	44, 23, 2, 152, 154, 5, 12, 7, 2, 153, 151, 3, 2, 2, 2, 153, 152, 3, 2,
	2, 2, 154, 11, 3, 2, 2, 2, 155, 156, 7, 15, 2, 2, 156, 157, 5, 68, 35,
	2, 157, 158, 7, 48, 2, 2, 158, 162, 5, 14, 8, 2, 159, 161, 5, 18, 10, 2,
	160, 159, 3, 2, 2, 2, 161, 164, 3, 2, 2, 2, 162, 160, 3, 2, 2, 2, 162,
	163, 3, 2, 2, 2, 163, 166, 3, 2, 2, 2, 164, 162, 3, 2, 2, 2, 165, 167,
	5, 20, 11, 2, 166, 165, 3, 2, 2, 2, 166, 167, 3, 2, 2, 2, 167, 230, 3,
	2, 2, 2, 168, 169, 7, 18, 2, 2, 169, 170, 5, 68, 35, 2, 170, 171, 7, 48,
	2, 2, 171, 173, 5, 14, 8, 2, 172, 174, 5, 20, 11, 2, 173, 172, 3, 2, 2,
	2, 173, 174, 3, 2, 2, 2, 174, 230, 3, 2, 2, 2, 175, 177, 7, 37, 2, 2, 176,
	175, 3, 2, 2, 2, 176, 177, 3, 2, 2, 2, 177, 178, 3, 2, 2, 2, 178, 179,
	7, 19, 2, 2, 179, 180, 5, 58, 30, 2, 180, 181, 7, 20, 2, 2, 181, 182, 5,
	92, 47, 2, 182, 183, 7, 48, 2, 2, 183, 185, 5, 14, 8, 2, 184, 186, 5, 20,
	11, 2, 185, 184, 3, 2, 2, 2, 185, 186, 3, 2, 2, 2, 186, 230, 3, 2, 2, 2,
	187, 188, 7, 21, 2, 2, 188, 189, 7, 48, 2, 2, 189, 202, 5, 14, 8, 2, 190,
	192, 5, 26, 14, 2, 191, 190, 3, 2, 2, 2, 192, 193, 3, 2, 2, 2, 193, 191,
	3, 2, 2, 2, 193, 194, 3, 2, 2, 2, 194, 196, 3, 2, 2, 2, 195, 197, 5, 20,
	11, 2, 196, 195, 3, 2, 2, 2, 196, 197, 3, 2, 2, 2, 197, 199, 3, 2, 2, 2,
	198, 200, 5, 22, 12, 2, 199, 198, 3, 2, 2, 2, 199, 200, 3, 2, 2, 2, 200,
	203, 3, 2, 2, 2, 201, 203, 5, 22, 12, 2, 202, 191, 3, 2, 2, 2, 202, 201,
	3, 2, 2, 2, 203, 230, 3, 2, 2, 2, 204, 206, 7, 37, 2, 2, 205, 204, 3, 2,
	2, 2, 205, 206, 3, 2, 2, 2, 206, 207, 3, 2, 2, 2, 207, 208, 7, 24, 2, 2,
	208, 213, 5, 24, 13, 2, 209, 210, 7, 47, 2, 2, 210, 212, 5, 24, 13, 2,
	211, 209, 3, 2, 2, 2, 212, 215, 3, 2, 2, 2, 213, 211, 3, 2, 2, 2, 213,
	214, 3, 2, 2, 2, 214, 216, 3, 2, 2, 2, 215, 213, 3, 2, 2, 2, 216, 217,
	7, 48, 2, 2, 217, 218, 5, 14, 8, 2, 218, 230, 3, 2, 2, 2, 219, 221, 5,
	16, 9, 2, 220, 219, 3, 2, 2, 2, 221, 224, 3, 2, 2, 2, 222, 220, 3, 2, 2,
	2, 222, 223, 3, 2, 2, 2, 223, 227, 3, 2, 2, 2, 224, 222, 3, 2, 2, 2, 225,
	228, 5, 28, 15, 2, 226, 228, 5, 30, 16, 2, 227, 225, 3, 2, 2, 2, 227, 226,
	3, 2, 2, 2, 228, 230, 3, 2, 2, 2, 229, 155, 3, 2, 2, 2, 229, 168, 3, 2,
	2, 2, 229, 176, 3, 2, 2, 2, 229, 187, 3, 2, 2, 2, 229, 205, 3, 2, 2, 2,
	229, 222, 3, 2, 2, 2, 230, 13, 3, 2, 2, 2, 231, 242, 5, 44, 23, 2, 232,
	233, 7, 5, 2, 2, 233, 235, 7, 3, 2, 2, 234, 236, 5, 10, 6, 2, 235, 234,
	3, 2, 2, 2, 236, 237, 3, 2, 2, 2, 237, 235, 3, 2, 2, 2, 237, 238, 3, 2,
	2, 2, 238, 239, 3, 2, 2, 2, 239, 240, 7, 4, 2, 2, 240, 242, 3, 2, 2, 2,
	241, 231, 3, 2, 2, 2, 241, 232, 3, 2, 2, 2, 242, 15, 3, 2, 2, 2, 243, 244,
	7, 70, 2, 2, 244, 250, 5, 94, 48, 2, 245, 247, 7, 92, 2, 2, 246, 248, 5,
	110, 56, 2, 247, 246, 3, 2, 2, 2, 247, 248, 3, 2, 2, 2, 248, 249, 3, 2,
	2, 2, 249, 251, 7, 93, 2, 2, 250, 245, 3, 2, 2, 2, 250, 251, 3, 2, 2, 2,
	251, 252, 3, 2, 2, 2, 252, 253, 7, 5, 2, 2, 253, 17, 3, 2, 2, 2, 254, 255,
	7, 16, 2, 2, 255, 256, 5, 68, 35, 2, 256, 257, 7, 48, 2, 2, 257, 258, 5,
	14, 8, 2, 258, 19, 3, 2, 2, 2, 259, 260, 7, 17, 2, 2, 260, 261, 7, 48,
	2, 2, 261, 262, 5, 14, 8, 2, 262, 21, 3, 2, 2, 2, 263, 264, 7, 23, 2, 2,
	264, 265, 7, 48, 2, 2, 265, 266, 5, 14, 8, 2, 266, 23, 3, 2, 2, 2, 267,
	270, 5, 68, 35, 2, 268, 269, 7, 12, 2, 2, 269, 271, 5, 84, 43, 2, 270,
	268, 3, 2, 2, 2, 270, 271, 3, 2, 2, 2, 271, 25, 3, 2, 2, 2, 272, 286, 7,
	25, 2, 2, 273, 284, 5, 68, 35, 2, 274, 275, 6, 14, 2, 2, 275, 276, 7, 47,
	2, 2, 276, 277, 5, 96, 49, 2, 277, 278, 8, 14, 1, 2, 278, 285, 3, 2, 2,
	2, 279, 280, 6, 14, 3, 2, 280, 281, 7, 12, 2, 2, 281, 282, 5, 96, 49, 2,
	282, 283, 8, 14, 1, 2, 283, 285, 3, 2, 2, 2, 284, 274, 3, 2, 2, 2, 284,
	279, 3, 2, 2, 2, 284, 285, 3, 2, 2, 2, 285, 287, 3, 2, 2, 2, 286, 273,
	3, 2, 2, 2, 286, 287, 3, 2, 2, 2, 287, 288, 3, 2, 2, 2, 288, 289, 7, 48,
	2, 2, 289, 290, 5, 14, 8, 2, 290, 27, 3, 2, 2, 2, 291, 292, 7, 31, 2, 2,
	292, 298, 5, 96, 49, 2, 293, 295, 7, 92, 2, 2, 294, 296, 5, 110, 56, 2,
	295, 294, 3, 2, 2, 2, 295, 296, 3, 2, 2, 2, 296, 297, 3, 2, 2, 2, 297,
	299, 7, 93, 2, 2, 298, 293, 3, 2, 2, 2, 298, 299, 3, 2, 2, 2, 299, 300,
	3, 2, 2, 2, 300, 301, 7, 48, 2, 2, 301, 302, 5, 14, 8, 2, 302, 29, 3, 2,
	2, 2, 303, 305, 7, 37, 2, 2, 304, 303, 3, 2, 2, 2, 304, 305, 3, 2, 2, 2,
	305, 306, 3, 2, 2, 2, 306, 307, 7, 6, 2, 2, 307, 308, 5, 96, 49, 2, 308,
	310, 7, 92, 2, 2, 309, 311, 5, 32, 17, 2, 310, 309, 3, 2, 2, 2, 310, 311,
	3, 2, 2, 2, 311, 312, 3, 2, 2, 2, 312, 315, 7, 93, 2, 2, 313, 314, 7, 71,
	2, 2, 314, 316, 5, 68, 35, 2, 315, 313, 3, 2, 2, 2, 315, 316, 3, 2, 2,
	2, 316, 317, 3, 2, 2, 2, 317, 318, 7, 48, 2, 2, 318, 319, 5, 14, 8, 2,
	319, 31, 3, 2, 2, 2, 320, 321, 5, 38, 20, 2, 321, 322, 7, 47, 2, 2, 322,
	324, 3, 2, 2, 2, 323, 320, 3, 2, 2, 2, 323, 324, 3, 2, 2, 2, 324, 335,
	3, 2, 2, 2, 325, 328, 5, 34, 18, 2, 326, 327, 7, 47, 2, 2, 327, 329, 5,
	38, 20, 2, 328, 326, 3, 2, 2, 2, 328, 329, 3, 2, 2, 2, 329, 332, 3, 2,
	2, 2, 330, 331, 7, 47, 2, 2, 331, 333, 5, 36, 19, 2, 332, 330, 3, 2, 2,
	2, 332, 333, 3, 2, 2, 2, 333, 336, 3, 2, 2, 2, 334, 336, 5, 36, 19, 2,
	335, 325, 3, 2, 2, 2, 335, 334, 3, 2, 2, 2, 336, 338, 3, 2, 2, 2, 337,
	339, 7, 47, 2, 2, 338, 337, 3, 2, 2, 2, 338, 339, 3, 2, 2, 2, 339, 345,
	3, 2, 2, 2, 340, 342, 5, 38, 20, 2, 341, 343, 7, 47, 2, 2, 342, 341, 3,
	2, 2, 2, 342, 343, 3, 2, 2, 2, 343, 345, 3, 2, 2, 2, 344, 323, 3, 2, 2,
	2, 344, 340, 3, 2, 2, 2, 345, 33, 3, 2, 2, 2, 346, 347, 7, 46, 2, 2, 347,
	348, 5, 42, 22, 2, 348, 35, 3, 2, 2, 2, 349, 350, 7, 50, 2, 2, 350, 351,
	5, 42, 22, 2, 351, 37, 3, 2, 2, 2, 352, 357, 5, 40, 21, 2, 353, 354, 7,
	47, 2, 2, 354, 356, 5, 40, 21, 2, 355, 353, 3, 2, 2, 2, 356, 359, 3, 2,
	2, 2, 357, 355, 3, 2, 2, 2, 357, 358, 3, 2, 2, 2, 358, 39, 3, 2, 2, 2,
	359, 357, 3, 2, 2, 2, 360, 363, 5, 42, 22, 2, 361, 362, 7, 51, 2, 2, 362,
	364, 5, 68, 35, 2, 363, 361, 3, 2, 2, 2, 363, 364, 3, 2, 2, 2, 364, 367,
	3, 2, 2, 2, 365, 367, 7, 46, 2, 2, 366, 360, 3, 2, 2, 2, 366, 365, 3, 2,
	2, 2, 367, 41, 3, 2, 2, 2, 368, 371, 5, 96, 49, 2, 369, 370, 7, 48, 2,
	2, 370, 372, 5, 68, 35, 2, 371, 369, 3, 2, 2, 2, 371, 372, 3, 2, 2, 2,
	372, 43, 3, 2, 2, 2, 373, 378, 5, 46, 24, 2, 374, 375, 7, 49, 2, 2, 375,
	377, 5, 46, 24, 2, 376, 374, 3, 2, 2, 2, 377, 380, 3, 2, 2, 2, 378, 376,
	3, 2, 2, 2, 378, 379, 3, 2, 2, 2, 379, 382, 3, 2, 2, 2, 380, 378, 3, 2,
	2, 2, 381, 383, 7, 49, 2, 2, 382, 381, 3, 2, 2, 2, 382, 383, 3, 2, 2, 2,
	383, 384, 3, 2, 2, 2, 384, 385, 9, 2, 2, 2, 385, 45, 3, 2, 2, 2, 386, 388,
	5, 52, 27, 2, 387, 389, 5, 56, 29, 2, 388, 387, 3, 2, 2, 2, 388, 389, 3,
	2, 2, 2, 389, 492, 3, 2, 2, 2, 390, 391, 6, 24, 4, 2, 391, 414, 7, 39,
	2, 2, 392, 397, 5, 68, 35, 2, 393, 394, 7, 47, 2, 2, 394, 396, 5, 68, 35,
	2, 395, 393, 3, 2, 2, 2, 396, 399, 3, 2, 2, 2, 397, 395, 3, 2, 2, 2, 397,
	398, 3, 2, 2, 2, 398, 401, 3, 2, 2, 2, 399, 397, 3, 2, 2, 2, 400, 402,
	7, 47, 2, 2, 401, 400, 3, 2, 2, 2, 401, 402, 3, 2, 2, 2, 402, 415, 3, 2,
	2, 2, 403, 404, 7, 56, 2, 2, 404, 407, 5, 68, 35, 2, 405, 406, 7, 47, 2,
	2, 406, 408, 5, 68, 35, 2, 407, 405, 3, 2, 2, 2, 408, 409, 3, 2, 2, 2,
	409, 407, 3, 2, 2, 2, 409, 410, 3, 2, 2, 2, 410, 412, 3, 2, 2, 2, 411,
	413, 7, 47, 2, 2, 412, 411, 3, 2, 2, 2, 412, 413, 3, 2, 2, 2, 413, 415,
	3, 2, 2, 2, 414, 392, 3, 2, 2, 2, 414, 403, 3, 2, 2, 2, 415, 416, 3, 2,
	2, 2, 416, 417, 8, 24, 1, 2, 417, 492, 3, 2, 2, 2, 418, 419, 7, 33, 2,
	2, 419, 492, 5, 58, 30, 2, 420, 492, 7, 34, 2, 2, 421, 492, 7, 36, 2, 2,
	422, 492, 7, 35, 2, 2, 423, 425, 7, 7, 2, 2, 424, 426, 5, 92, 47, 2, 425,
	424, 3, 2, 2, 2, 425, 426, 3, 2, 2, 2, 426, 492, 3, 2, 2, 2, 427, 437,
	7, 8, 2, 2, 428, 435, 5, 68, 35, 2, 429, 430, 7, 47, 2, 2, 430, 433, 5,
	68, 35, 2, 431, 432, 7, 47, 2, 2, 432, 434, 5, 68, 35, 2, 433, 431, 3,
	2, 2, 2, 433, 434, 3, 2, 2, 2, 434, 436, 3, 2, 2, 2, 435, 429, 3, 2, 2,
	2, 435, 436, 3, 2, 2, 2, 436, 438, 3, 2, 2, 2, 437, 428, 3, 2, 2, 2, 437,
	438, 3, 2, 2, 2, 438, 441, 3, 2, 2, 2, 439, 440, 7, 9, 2, 2, 440, 442,
	5, 68, 35, 2, 441, 439, 3, 2, 2, 2, 441, 442, 3, 2, 2, 2, 442, 492, 3,
	2, 2, 2, 443, 492, 5, 102, 52, 2, 444, 445, 7, 10, 2, 2, 445, 492, 5, 64,
	33, 2, 446, 447, 7, 9, 2, 2, 447, 448, 5, 48, 25, 2, 448, 449, 7, 10, 2,
	2, 449, 450, 5, 50, 26, 2, 450, 492, 3, 2, 2, 2, 451, 452, 7, 13, 2, 2,
	452, 457, 5, 96, 49, 2, 453, 454, 7, 47, 2, 2, 454, 456, 5, 96, 49, 2,
	455, 453, 3, 2, 2, 2, 456, 459, 3, 2, 2, 2, 457, 455, 3, 2, 2, 2, 457,
	458, 3, 2, 2, 2, 458, 492, 3, 2, 2, 2, 459, 457, 3, 2, 2, 2, 460, 461,
	6, 24, 5, 2, 461, 462, 7, 40, 2, 2, 462, 469, 5, 84, 43, 2, 463, 464, 7,
	20, 2, 2, 464, 467, 5, 68, 35, 2, 465, 466, 7, 47, 2, 2, 466, 468, 5, 68,
	35, 2, 467, 465, 3, 2, 2, 2, 467, 468, 3, 2, 2, 2, 468, 470, 3, 2, 2, 2,
	469, 463, 3, 2, 2, 2, 469, 470, 3, 2, 2, 2, 470, 471, 3, 2, 2, 2, 471,
	472, 8, 24, 1, 2, 472, 492, 3, 2, 2, 2, 473, 474, 7, 14, 2, 2, 474, 477,
	5, 68, 35, 2, 475, 476, 7, 47, 2, 2, 476, 478, 5, 68, 35, 2, 477, 475,
	3, 2, 2, 2, 477, 478, 3, 2, 2, 2, 478, 492, 3, 2, 2, 2, 479, 480, 6, 24,
	6, 2, 480, 481, 7, 11, 2, 2, 481, 486, 5, 96, 49, 2, 482, 483, 7, 47, 2,
	2, 483, 485, 5, 96, 49, 2, 484, 482, 3, 2, 2, 2, 485, 488, 3, 2, 2, 2,
	486, 484, 3, 2, 2, 2, 486, 487, 3, 2, 2, 2, 487, 489, 3, 2, 2, 2, 488,
	486, 3, 2, 2, 2, 489, 490, 8, 24, 1, 2, 490, 492, 3, 2, 2, 2, 491, 386,
	3, 2, 2, 2, 491, 390, 3, 2, 2, 2, 491, 418, 3, 2, 2, 2, 491, 420, 3, 2,
	2, 2, 491, 421, 3, 2, 2, 2, 491, 422, 3, 2, 2, 2, 491, 423, 3, 2, 2, 2,
	491, 427, 3, 2, 2, 2, 491, 443, 3, 2, 2, 2, 491, 444, 3, 2, 2, 2, 491,
	446, 3, 2, 2, 2, 491, 451, 3, 2, 2, 2, 491, 460, 3, 2, 2, 2, 491, 473,
	3, 2, 2, 2, 491, 479, 3, 2, 2, 2, 492, 47, 3, 2, 2, 2, 493, 495, 9, 3,
	2, 2, 494, 493, 3, 2, 2, 2, 495, 498, 3, 2, 2, 2, 496, 494, 3, 2, 2, 2,
	496, 497, 3, 2, 2, 2, 497, 499, 3, 2, 2, 2, 498, 496, 3, 2, 2, 2, 499,
	506, 5, 94, 48, 2, 500, 502, 9, 3, 2, 2, 501, 500, 3, 2, 2, 2, 502, 503,
	3, 2, 2, 2, 503, 501, 3, 2, 2, 2, 503, 504, 3, 2, 2, 2, 504, 506, 3, 2,
	2, 2, 505, 496, 3, 2, 2, 2, 505, 501, 3, 2, 2, 2, 506, 49, 3, 2, 2, 2,
	507, 514, 7, 46, 2, 2, 508, 509, 7, 92, 2, 2, 509, 510, 5, 60, 31, 2, 510,
	511, 7, 93, 2, 2, 511, 514, 3, 2, 2, 2, 512, 514, 5, 60, 31, 2, 513, 507,
	3, 2, 2, 2, 513, 508, 3, 2, 2, 2, 513, 512, 3, 2, 2, 2, 514, 51, 3, 2,
	2, 2, 515, 518, 5, 68, 35, 2, 516, 518, 5, 54, 28, 2, 517, 515, 3, 2, 2,
	2, 517, 516, 3, 2, 2, 2, 518, 519, 3, 2, 2, 2, 519, 520, 7, 47, 2, 2, 520,
	522, 3, 2, 2, 2, 521, 517, 3, 2, 2, 2, 522, 523, 3, 2, 2, 2, 523, 521,
	3, 2, 2, 2, 523, 524, 3, 2, 2, 2, 524, 527, 3, 2, 2, 2, 525, 528, 5, 68,
	35, 2, 526, 528, 5, 54, 28, 2, 527, 525, 3, 2, 2, 2, 527, 526, 3, 2, 2,
	2, 527, 528, 3, 2, 2, 2, 528, 531, 3, 2, 2, 2, 529, 531, 5, 92, 47, 2,
	530, 521, 3, 2, 2, 2, 530, 529, 3, 2, 2, 2, 531, 53, 3, 2, 2, 2, 532, 533,
	7, 46, 2, 2, 533, 534, 5, 84, 43, 2, 534, 55, 3, 2, 2, 2, 535, 549, 7,
	51, 2, 2, 536, 541, 5, 52, 27, 2, 537, 538, 7, 51, 2, 2, 538, 540, 5, 52,
	27, 2, 539, 537, 3, 2, 2, 2, 540, 543, 3, 2, 2, 2, 541, 539, 3, 2, 2, 2,
	541, 542, 3, 2, 2, 2, 542, 546, 3, 2, 2, 2, 543, 541, 3, 2, 2, 2, 544,
	545, 7, 51, 2, 2, 545, 547, 5, 102, 52, 2, 546, 544, 3, 2, 2, 2, 546, 547,
	3, 2, 2, 2, 547, 550, 3, 2, 2, 2, 548, 550, 5, 102, 52, 2, 549, 536, 3,
	2, 2, 2, 549, 548, 3, 2, 2, 2, 550, 566, 3, 2, 2, 2, 551, 552, 6, 29, 7,
	2, 552, 553, 7, 48, 2, 2, 553, 556, 5, 68, 35, 2, 554, 555, 7, 51, 2, 2,
	555, 557, 5, 92, 47, 2, 556, 554, 3, 2, 2, 2, 556, 557, 3, 2, 2, 2, 557,
	558, 3, 2, 2, 2, 558, 559, 8, 29, 1, 2, 559, 566, 3, 2, 2, 2, 560, 563,
	9, 4, 2, 2, 561, 564, 5, 102, 52, 2, 562, 564, 5, 92, 47, 2, 563, 561,
	3, 2, 2, 2, 563, 562, 3, 2, 2, 2, 564, 566, 3, 2, 2, 2, 565, 535, 3, 2,
	2, 2, 565, 551, 3, 2, 2, 2, 565, 560, 3, 2, 2, 2, 566, 57, 3, 2, 2, 2,
	567, 572, 5, 84, 43, 2, 568, 569, 7, 47, 2, 2, 569, 571, 5, 84, 43, 2,
	570, 568, 3, 2, 2, 2, 571, 574, 3, 2, 2, 2, 572, 570, 3, 2, 2, 2, 572,
	573, 3, 2, 2, 2, 573, 576, 3, 2, 2, 2, 574, 572, 3, 2, 2, 2, 575, 577,
	7, 47, 2, 2, 576, 575, 3, 2, 2, 2, 576, 577, 3, 2, 2, 2, 577, 59, 3, 2,
	2, 2, 578, 583, 5, 62, 32, 2, 579, 580, 7, 47, 2, 2, 580, 582, 5, 62, 32,
	2, 581, 579, 3, 2, 2, 2, 582, 585, 3, 2, 2, 2, 583, 581, 3, 2, 2, 2, 583,
	584, 3, 2, 2, 2, 584, 587, 3, 2, 2, 2, 585, 583, 3, 2, 2, 2, 586, 588,
	7, 47, 2, 2, 587, 586, 3, 2, 2, 2, 587, 588, 3, 2, 2, 2, 588, 61, 3, 2,
	2, 2, 589, 592, 5, 96, 49, 2, 590, 591, 7, 12, 2, 2, 591, 593, 5, 96, 49,
	2, 592, 590, 3, 2, 2, 2, 592, 593, 3, 2, 2, 2, 593, 63, 3, 2, 2, 2, 594,
	599, 5, 66, 34, 2, 595, 596, 7, 47, 2, 2, 596, 598, 5, 66, 34, 2, 597,
	595, 3, 2, 2, 2, 598, 601, 3, 2, 2, 2, 599, 597, 3, 2, 2, 2, 599, 600,
	3, 2, 2, 2, 600, 65, 3, 2, 2, 2, 601, 599, 3, 2, 2, 2, 602, 605, 5, 94,
	48, 2, 603, 604, 7, 12, 2, 2, 604, 606, 5, 96, 49, 2, 605, 603, 3, 2, 2,
	2, 605, 606, 3, 2, 2, 2, 606, 67, 3, 2, 2, 2, 607, 613, 5, 80, 41, 2, 608,
	609, 7, 15, 2, 2, 609, 610, 5, 80, 41, 2, 610, 611, 7, 17, 2, 2, 611, 612,
	5, 68, 35, 2, 612, 614, 3, 2, 2, 2, 613, 608, 3, 2, 2, 2, 613, 614, 3,
	2, 2, 2, 614, 622, 3, 2, 2, 2, 615, 617, 7, 26, 2, 2, 616, 618, 5, 70,
	36, 2, 617, 616, 3, 2, 2, 2, 617, 618, 3, 2, 2, 2, 618, 619, 3, 2, 2, 2,
	619, 620, 7, 48, 2, 2, 620, 622, 5, 68, 35, 2, 621, 607, 3, 2, 2, 2, 621,
	615, 3, 2, 2, 2, 622, 69, 3, 2, 2, 2, 623, 624, 5, 72, 37, 2, 624, 625,
	7, 47, 2, 2, 625, 627, 3, 2, 2, 2, 626, 623, 3, 2, 2, 2, 626, 627, 3, 2,
	2, 2, 627, 638, 3, 2, 2, 2, 628, 631, 5, 76, 39, 2, 629, 630, 7, 47, 2,
	2, 630, 632, 5, 72, 37, 2, 631, 629, 3, 2, 2, 2, 631, 632, 3, 2, 2, 2,
	632, 635, 3, 2, 2, 2, 633, 634, 7, 47, 2, 2, 634, 636, 5, 78, 40, 2, 635,
	633, 3, 2, 2, 2, 635, 636, 3, 2, 2, 2, 636, 639, 3, 2, 2, 2, 637, 639,
	5, 78, 40, 2, 638, 628, 3, 2, 2, 2, 638, 637, 3, 2, 2, 2, 639, 641, 3,
	2, 2, 2, 640, 642, 7, 47, 2, 2, 641, 640, 3, 2, 2, 2, 641, 642, 3, 2, 2,
	2, 642, 648, 3, 2, 2, 2, 643, 645, 5, 72, 37, 2, 644, 646, 7, 47, 2, 2,
	645, 644, 3, 2, 2, 2, 645, 646, 3, 2, 2, 2, 646, 648, 3, 2, 2, 2, 647,
	626, 3, 2, 2, 2, 647, 643, 3, 2, 2, 2, 648, 71, 3, 2, 2, 2, 649, 654, 5,
	74, 38, 2, 650, 651, 7, 47, 2, 2, 651, 653, 5, 74, 38, 2, 652, 650, 3,
	2, 2, 2, 653, 656, 3, 2, 2, 2, 654, 652, 3, 2, 2, 2, 654, 655, 3, 2, 2,
	2, 655, 73, 3, 2, 2, 2, 656, 654, 3, 2, 2, 2, 657, 660, 5, 96, 49, 2, 658,
	659, 7, 51, 2, 2, 659, 661, 5, 68, 35, 2, 660, 658, 3, 2, 2, 2, 660, 661,
	3, 2, 2, 2, 661, 664, 3, 2, 2, 2, 662, 664, 7, 46, 2, 2, 663, 657, 3, 2,
	2, 2, 663, 662, 3, 2, 2, 2, 664, 75, 3, 2, 2, 2, 665, 666, 7, 46, 2, 2,
	666, 667, 5, 96, 49, 2, 667, 77, 3, 2, 2, 2, 668, 669, 7, 50, 2, 2, 669,
	670, 5, 96, 49, 2, 670, 79, 3, 2, 2, 2, 671, 672, 8, 41, 1, 2, 672, 676,
	5, 82, 42, 2, 673, 674, 7, 29, 2, 2, 674, 676, 5, 80, 41, 5, 675, 671,
	3, 2, 2, 2, 675, 673, 3, 2, 2, 2, 676, 685, 3, 2, 2, 2, 677, 678, 12, 4,
	2, 2, 678, 679, 7, 28, 2, 2, 679, 684, 5, 80, 41, 5, 680, 681, 12, 3, 2,
	2, 681, 682, 7, 27, 2, 2, 682, 684, 5, 80, 41, 4, 683, 677, 3, 2, 2, 2,
	683, 680, 3, 2, 2, 2, 684, 687, 3, 2, 2, 2, 685, 683, 3, 2, 2, 2, 685,
	686, 3, 2, 2, 2, 686, 81, 3, 2, 2, 2, 687, 685, 3, 2, 2, 2, 688, 689, 8,
	42, 1, 2, 689, 690, 5, 84, 43, 2, 690, 712, 3, 2, 2, 2, 691, 707, 12, 4,
	2, 2, 692, 708, 7, 63, 2, 2, 693, 708, 7, 64, 2, 2, 694, 708, 7, 65, 2,
	2, 695, 708, 7, 66, 2, 2, 696, 708, 7, 67, 2, 2, 697, 708, 7, 68, 2, 2,
	698, 708, 7, 69, 2, 2, 699, 701, 7, 29, 2, 2, 700, 699, 3, 2, 2, 2, 700,
	701, 3, 2, 2, 2, 701, 702, 3, 2, 2, 2, 702, 708, 7, 20, 2, 2, 703, 705,
	7, 30, 2, 2, 704, 706, 7, 29, 2, 2, 705, 704, 3, 2, 2, 2, 705, 706, 3,
	2, 2, 2, 706, 708, 3, 2, 2, 2, 707, 692, 3, 2, 2, 2, 707, 693, 3, 2, 2,
	2, 707, 694, 3, 2, 2, 2, 707, 695, 3, 2, 2, 2, 707, 696, 3, 2, 2, 2, 707,
	697, 3, 2, 2, 2, 707, 698, 3, 2, 2, 2, 707, 700, 3, 2, 2, 2, 707, 703,
	3, 2, 2, 2, 708, 709, 3, 2, 2, 2, 709, 711, 5, 82, 42, 5, 710, 691, 3,
	2, 2, 2, 711, 714, 3, 2, 2, 2, 712, 710, 3, 2, 2, 2, 712, 713, 3, 2, 2,
	2, 713, 83, 3, 2, 2, 2, 714, 712, 3, 2, 2, 2, 715, 717, 8, 43, 1, 2, 716,
	718, 7, 38, 2, 2, 717, 716, 3, 2, 2, 2, 717, 718, 3, 2, 2, 2, 718, 719,
	3, 2, 2, 2, 719, 723, 5, 86, 44, 2, 720, 722, 5, 106, 54, 2, 721, 720,
	3, 2, 2, 2, 722, 725, 3, 2, 2, 2, 723, 721, 3, 2, 2, 2, 723, 724, 3, 2,
	2, 2, 724, 729, 3, 2, 2, 2, 725, 723, 3, 2, 2, 2, 726, 727, 9, 5, 2, 2,
	727, 729, 5, 84, 43, 9, 728, 715, 3, 2, 2, 2, 728, 726, 3, 2, 2, 2, 729,
	753, 3, 2, 2, 2, 730, 731, 12, 10, 2, 2, 731, 732, 7, 50, 2, 2, 732, 752,
	5, 84, 43, 10, 733, 734, 12, 8, 2, 2, 734, 735, 9, 6, 2, 2, 735, 752, 5,
	84, 43, 9, 736, 737, 12, 7, 2, 2, 737, 738, 9, 7, 2, 2, 738, 752, 5, 84,
	43, 8, 739, 740, 12, 6, 2, 2, 740, 741, 9, 8, 2, 2, 741, 752, 5, 84, 43,
	7, 742, 743, 12, 5, 2, 2, 743, 744, 7, 54, 2, 2, 744, 752, 5, 84, 43, 6,
	745, 746, 12, 4, 2, 2, 746, 747, 7, 53, 2, 2, 747, 752, 5, 84, 43, 5, 748,
	749, 12, 3, 2, 2, 749, 750, 7, 52, 2, 2, 750, 752, 5, 84, 43, 4, 751, 730,
	3, 2, 2, 2, 751, 733, 3, 2, 2, 2, 751, 736, 3, 2, 2, 2, 751, 739, 3, 2,
	2, 2, 751, 742, 3, 2, 2, 2, 751, 745, 3, 2, 2, 2, 751, 748, 3, 2, 2, 2,
	752, 755, 3, 2, 2, 2, 753, 751, 3, 2, 2, 2, 753, 754, 3, 2, 2, 2, 754,
	85, 3, 2, 2, 2, 755, 753, 3, 2, 2, 2, 756, 759, 7, 92, 2, 2, 757, 760,
	5, 102, 52, 2, 758, 760, 5, 90, 46, 2, 759, 757, 3, 2, 2, 2, 759, 758,
	3, 2, 2, 2, 759, 760, 3, 2, 2, 2, 760, 761, 3, 2, 2, 2, 761, 794, 7, 93,
	2, 2, 762, 764, 7, 96, 2, 2, 763, 765, 5, 90, 46, 2, 764, 763, 3, 2, 2,
	2, 764, 765, 3, 2, 2, 2, 765, 766, 3, 2, 2, 2, 766, 794, 7, 97, 2, 2, 767,
	769, 7, 94, 2, 2, 768, 770, 5, 88, 45, 2, 769, 768, 3, 2, 2, 2, 769, 770,
	3, 2, 2, 2, 770, 771, 3, 2, 2, 2, 771, 794, 7, 95, 2, 2, 772, 773, 7, 45,
	2, 2, 773, 775, 5, 92, 47, 2, 774, 776, 7, 47, 2, 2, 775, 774, 3, 2, 2,
	2, 775, 776, 3, 2, 2, 2, 776, 777, 3, 2, 2, 2, 777, 778, 7, 45, 2, 2, 778,
	794, 3, 2, 2, 2, 779, 794, 7, 44, 2, 2, 780, 794, 5, 96, 49, 2, 781, 794,
	7, 39, 2, 2, 782, 794, 7, 40, 2, 2, 783, 785, 7, 58, 2, 2, 784, 783, 3,
	2, 2, 2, 784, 785, 3, 2, 2, 2, 785, 786, 3, 2, 2, 2, 786, 794, 5, 98, 50,
	2, 787, 794, 7, 22, 2, 2, 788, 790, 7, 85, 2, 2, 789, 788, 3, 2, 2, 2,
	790, 791, 3, 2, 2, 2, 791, 789, 3, 2, 2, 2, 791, 792, 3, 2, 2, 2, 792,
	794, 3, 2, 2, 2, 793, 756, 3, 2, 2, 2, 793, 762, 3, 2, 2, 2, 793, 767,
	3, 2, 2, 2, 793, 772, 3, 2, 2, 2, 793, 779, 3, 2, 2, 2, 793, 780, 3, 2,
	2, 2, 793, 781, 3, 2, 2, 2, 793, 782, 3, 2, 2, 2, 793, 784, 3, 2, 2, 2,
	793, 787, 3, 2, 2, 2, 793, 789, 3, 2, 2, 2, 794, 87, 3, 2, 2, 2, 795, 796,
	5, 68, 35, 2, 796, 797, 7, 48, 2, 2, 797, 798, 5, 68, 35, 2, 798, 802,
	3, 2, 2, 2, 799, 800, 7, 50, 2, 2, 800, 802, 5, 84, 43, 2, 801, 795, 3,
	2, 2, 2, 801, 799, 3, 2, 2, 2, 802, 814, 3, 2, 2, 2, 803, 810, 7, 47, 2,
	2, 804, 805, 5, 68, 35, 2, 805, 806, 7, 48, 2, 2, 806, 807, 5, 68, 35,
	2, 807, 811, 3, 2, 2, 2, 808, 809, 7, 50, 2, 2, 809, 811, 5, 84, 43, 2,
	810, 804, 3, 2, 2, 2, 810, 808, 3, 2, 2, 2, 811, 813, 3, 2, 2, 2, 812,
	803, 3, 2, 2, 2, 813, 816, 3, 2, 2, 2, 814, 812, 3, 2, 2, 2, 814, 815,
	3, 2, 2, 2, 815, 818, 3, 2, 2, 2, 816, 814, 3, 2, 2, 2, 817, 819, 7, 47,
	2, 2, 818, 817, 3, 2, 2, 2, 818, 819, 3, 2, 2, 2, 819, 827, 3, 2, 2, 2,
	820, 821, 5, 68, 35, 2, 821, 822, 7, 48, 2, 2, 822, 823, 5, 68, 35, 2,
	823, 824, 5, 120, 61, 2, 824, 827, 3, 2, 2, 2, 825, 827, 5, 90, 46, 2,
	826, 801, 3, 2, 2, 2, 826, 820, 3, 2, 2, 2, 826, 825, 3, 2, 2, 2, 827,
	89, 3, 2, 2, 2, 828, 831, 5, 68, 35, 2, 829, 831, 5, 54, 28, 2, 830, 828,
	3, 2, 2, 2, 830, 829, 3, 2, 2, 2, 831, 846, 3, 2, 2, 2, 832, 847, 5, 120,
	61, 2, 833, 836, 7, 47, 2, 2, 834, 837, 5, 68, 35, 2, 835, 837, 5, 54,
	28, 2, 836, 834, 3, 2, 2, 2, 836, 835, 3, 2, 2, 2, 837, 839, 3, 2, 2, 2,
	838, 833, 3, 2, 2, 2, 839, 842, 3, 2, 2, 2, 840, 838, 3, 2, 2, 2, 840,
	841, 3, 2, 2, 2, 841, 844, 3, 2, 2, 2, 842, 840, 3, 2, 2, 2, 843, 845,
	7, 47, 2, 2, 844, 843, 3, 2, 2, 2, 844, 845, 3, 2, 2, 2, 845, 847, 3, 2,
	2, 2, 846, 832, 3, 2, 2, 2, 846, 840, 3, 2, 2, 2, 847, 91, 3, 2, 2, 2,
	848, 853, 5, 68, 35, 2, 849, 850, 7, 47, 2, 2, 850, 852, 5, 68, 35, 2,
	851, 849, 3, 2, 2, 2, 852, 855, 3, 2, 2, 2, 853, 851, 3, 2, 2, 2, 853,
	854, 3, 2, 2, 2, 854, 857, 3, 2, 2, 2, 855, 853, 3, 2, 2, 2, 856, 858,
	7, 47, 2, 2, 857, 856, 3, 2, 2, 2, 857, 858, 3, 2, 2, 2, 858, 93, 3, 2,
	2, 2, 859, 860, 8, 48, 1, 2, 860, 861, 5, 96, 49, 2, 861, 867, 3, 2, 2,
	2, 862, 863, 12, 4, 2, 2, 863, 864, 7, 43, 2, 2, 864, 866, 5, 96, 49, 2,
	865, 862, 3, 2, 2, 2, 866, 869, 3, 2, 2, 2, 867, 865, 3, 2, 2, 2, 867,
	868, 3, 2, 2, 2, 868, 95, 3, 2, 2, 2, 869, 867, 3, 2, 2, 2, 870, 871, 9,
	9, 2, 2, 871, 97, 3, 2, 2, 2, 872, 876, 5, 100, 51, 2, 873, 876, 7, 90,
	2, 2, 874, 876, 7, 91, 2, 2, 875, 872, 3, 2, 2, 2, 875, 873, 3, 2, 2, 2,
	875, 874, 3, 2, 2, 2, 876, 99, 3, 2, 2, 2, 877, 878, 9, 10, 2, 2, 878,
	101, 3, 2, 2, 2, 879, 881, 7, 32, 2, 2, 880, 882, 5, 104, 53, 2, 881, 880,
	3, 2, 2, 2, 881, 882, 3, 2, 2, 2, 882, 103, 3, 2, 2, 2, 883, 884, 7, 9,
	2, 2, 884, 887, 5, 68, 35, 2, 885, 887, 5, 92, 47, 2, 886, 883, 3, 2, 2,
	2, 886, 885, 3, 2, 2, 2, 887, 105, 3, 2, 2, 2, 888, 889, 7, 43, 2, 2, 889,
	891, 5, 96, 49, 2, 890, 892, 5, 108, 55, 2, 891, 890, 3, 2, 2, 2, 891,
	892, 3, 2, 2, 2, 892, 895, 3, 2, 2, 2, 893, 895, 5, 108, 55, 2, 894, 888,
	3, 2, 2, 2, 894, 893, 3, 2, 2, 2, 895, 107, 3, 2, 2, 2, 896, 898, 7, 92,
	2, 2, 897, 899, 5, 110, 56, 2, 898, 897, 3, 2, 2, 2, 898, 899, 3, 2, 2,
	2, 899, 900, 3, 2, 2, 2, 900, 906, 7, 93, 2, 2, 901, 902, 7, 96, 2, 2,
	902, 903, 5, 114, 58, 2, 903, 904, 7, 97, 2, 2, 904, 906, 3, 2, 2, 2, 905,
	896, 3, 2, 2, 2, 905, 901, 3, 2, 2, 2, 906, 109, 3, 2, 2, 2, 907, 912,
	5, 112, 57, 2, 908, 909, 7, 47, 2, 2, 909, 911, 5, 112, 57, 2, 910, 908,
	3, 2, 2, 2, 911, 914, 3, 2, 2, 2, 912, 910, 3, 2, 2, 2, 912, 913, 3, 2,
	2, 2, 913, 916, 3, 2, 2, 2, 914, 912, 3, 2, 2, 2, 915, 917, 7, 47, 2, 2,
	916, 915, 3, 2, 2, 2, 916, 917, 3, 2, 2, 2, 917, 111, 3, 2, 2, 2, 918,
	922, 5, 68, 35, 2, 919, 923, 5, 120, 61, 2, 920, 921, 7, 51, 2, 2, 921,
	923, 5, 68, 35, 2, 922, 919, 3, 2, 2, 2, 922, 920, 3, 2, 2, 2, 922, 923,
	3, 2, 2, 2, 923, 927, 3, 2, 2, 2, 924, 925, 9, 11, 2, 2, 925, 927, 5, 68,
	35, 2, 926, 918, 3, 2, 2, 2, 926, 924, 3, 2, 2, 2, 927, 113, 3, 2, 2, 2,
	928, 933, 5, 116, 59, 2, 929, 930, 7, 47, 2, 2, 930, 932, 5, 116, 59, 2,
	931, 929, 3, 2, 2, 2, 932, 935, 3, 2, 2, 2, 933, 931, 3, 2, 2, 2, 933,
	934, 3, 2, 2, 2, 934, 937, 3, 2, 2, 2, 935, 933, 3, 2, 2, 2, 936, 938,
	7, 47, 2, 2, 937, 936, 3, 2, 2, 2, 937, 938, 3, 2, 2, 2, 938, 115, 3, 2,
	2, 2, 939, 958, 7, 44, 2, 2, 940, 948, 5, 68, 35, 2, 941, 943, 7, 48, 2,
	2, 942, 944, 5, 68, 35, 2, 943, 942, 3, 2, 2, 2, 943, 944, 3, 2, 2, 2,
	944, 946, 3, 2, 2, 2, 945, 947, 5, 118, 60, 2, 946, 945, 3, 2, 2, 2, 946,
	947, 3, 2, 2, 2, 947, 949, 3, 2, 2, 2, 948, 941, 3, 2, 2, 2, 948, 949,
	3, 2, 2, 2, 949, 958, 3, 2, 2, 2, 950, 952, 7, 48, 2, 2, 951, 953, 5, 68,
	35, 2, 952, 951, 3, 2, 2, 2, 952, 953, 3, 2, 2, 2, 953, 955, 3, 2, 2, 2,
	954, 956, 5, 118, 60, 2, 955, 954, 3, 2, 2, 2, 955, 956, 3, 2, 2, 2, 956,
	958, 3, 2, 2, 2, 957, 939, 3, 2, 2, 2, 957, 940, 3, 2, 2, 2, 957, 950,
	3, 2, 2, 2, 958, 117, 3, 2, 2, 2, 959, 961, 7, 48, 2, 2, 960, 962, 5, 68,
	35, 2, 961, 960, 3, 2, 2, 2, 961, 962, 3, 2, 2, 2, 962, 119, 3, 2, 2, 2,
	963, 964, 7, 19, 2, 2, 964, 965, 5, 58, 30, 2, 965, 966, 7, 20, 2, 2, 966,
	968, 5, 80, 41, 2, 967, 969, 5, 122, 62, 2, 968, 967, 3, 2, 2, 2, 968,
	969, 3, 2, 2, 2, 969, 121, 3, 2, 2, 2, 970, 977, 5, 120, 61, 2, 971, 972,
	7, 15, 2, 2, 972, 974, 5, 68, 35, 2, 973, 975, 5, 122, 62, 2, 974, 973,
	3, 2, 2, 2, 974, 975, 3, 2, 2, 2, 975, 977, 3, 2, 2, 2, 976, 970, 3, 2,
	2, 2, 976, 971, 3, 2, 2, 2, 977, 123, 3, 2, 2, 2, 153, 127, 136, 140, 142,
	148, 153, 162, 166, 173, 176, 185, 193, 196, 199, 202, 205, 213, 222, 227,
	229, 237, 241, 247, 250, 270, 284, 286, 295, 298, 304, 310, 315, 323, 328,
	332, 335, 338, 342, 344, 357, 363, 366, 371, 378, 382, 388, 397, 401, 409,
	412, 414, 425, 433, 435, 437, 441, 457, 467, 469, 477, 486, 491, 496, 503,
	505, 513, 517, 523, 527, 530, 541, 546, 549, 556, 563, 565, 572, 576, 583,
	587, 592, 599, 605, 613, 617, 621, 626, 631, 635, 638, 641, 645, 647, 654,
	660, 663, 675, 683, 685, 700, 705, 707, 712, 717, 723, 728, 751, 753, 759,
	764, 769, 775, 784, 791, 793, 801, 810, 814, 818, 826, 830, 836, 840, 844,
	846, 853, 857, 867, 875, 881, 886, 891, 894, 898, 905, 912, 916, 922, 926,
	933, 937, 943, 946, 948, 952, 955, 957, 961, 968, 974, 976,
}
var deserializer = antlr.NewATNDeserializer(nil)
var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
	"", "", "", "", "'def'", "'return'", "'raise'", "'from'", "'import'", "'nonlocal'",
	"'as'", "'global'", "'assert'", "'if'", "'elif'", "'else'", "'while'",
	"'for'", "'in'", "'try'", "'None'", "'finally'", "'with'", "'except'",
	"'lambda'", "'or'", "'and'", "'not'", "'is'", "'class'", "'yield'", "'del'",
	"'pass'", "'continue'", "'break'", "'async'", "'await'", "'print'", "'exec'",
	"'True'", "'False'", "'.'", "'...'", "'`'", "'*'", "','", "':'", "';'",
	"'**'", "'='", "'|'", "'^'", "'&'", "'<<'", "'>>'", "'+'", "'-'", "'/'",
	"'%'", "'//'", "'~'", "'<'", "'>'", "'=='", "'>='", "'<='", "'<>'", "'!='",
	"'@'", "'->'", "'+='", "'-='", "'*='", "'@='", "'/='", "'%='", "'&='",
	"'|='", "'^='", "'<<='", "'>>='", "'**='", "'//='", "", "", "", "", "",
	"", "", "'('", "')'", "'{'", "'}'", "'['", "']'",
}
var symbolicNames = []string{
	"", "INDENT", "DEDENT", "LINE_BREAK", "DEF", "RETURN", "RAISE", "FROM",
	"IMPORT", "NONLOCAL", "AS", "GLOBAL", "ASSERT", "IF", "ELIF", "ELSE", "WHILE",
	"FOR", "IN", "TRY", "NONE", "FINALLY", "WITH", "EXCEPT", "LAMBDA", "OR",
	"AND", "NOT", "IS", "CLASS", "YIELD", "DEL", "PASS", "CONTINUE", "BREAK",
	"ASYNC", "AWAIT", "PRINT", "EXEC", "TRUE", "FALSE", "DOT", "ELLIPSIS",
	"REVERSE_QUOTE", "STAR", "COMMA", "COLON", "SEMI_COLON", "POWER", "ASSIGN",
	"OR_OP", "XOR", "AND_OP", "LEFT_SHIFT", "RIGHT_SHIFT", "ADD", "MINUS",
	"DIV", "MOD", "IDIV", "NOT_OP", "LESS_THAN", "GREATER_THAN", "EQUALS",
	"GT_EQ", "LT_EQ", "NOT_EQ_1", "NOT_EQ_2", "AT", "ARROW", "ADD_ASSIGN",
	"SUB_ASSIGN", "MULT_ASSIGN", "AT_ASSIGN", "DIV_ASSIGN", "MOD_ASSIGN", "AND_ASSIGN",
	"OR_ASSIGN", "XOR_ASSIGN", "LEFT_SHIFT_ASSIGN", "RIGHT_SHIFT_ASSIGN", "POWER_ASSIGN",
	"IDIV_ASSIGN", "STRING", "DECIMAL_INTEGER", "OCT_INTEGER", "HEX_INTEGER",
	"BIN_INTEGER", "IMAG_NUMBER", "FLOAT_NUMBER", "OPEN_PAREN", "CLOSE_PAREN",
	"OPEN_BRACE", "CLOSE_BRACE", "OPEN_BRACKET", "CLOSE_BRACKET", "NAME", "LINE_JOIN",
	"NEWLINE", "WS", "COMMENT",
}

var ruleNames = []string{
	"root", "single_input", "file_input", "eval_input", "stmt", "compound_stmt",
	"suite", "decorator", "elif_clause", "else_clause", "finally_clause", "with_item",
	"except_clause", "classdef", "funcdef", "typedargslist", "args", "kwargs",
	"def_parameters", "def_parameter", "named_parameter", "simple_stmt", "small_stmt",
	"from_stmt_source", "from_stmt_as_names", "testlist_star_expr", "star_expr",
	"assign_part", "exprlist", "import_as_names", "import_as_name", "dotted_as_names",
	"dotted_as_name", "test", "varargslist", "vardef_parameters", "vardef_parameter",
	"varargs", "varkwargs", "logical_test", "comparison", "expr", "atom", "dictorsetmaker",
	"testlist_comp", "testlist", "dotted_name", "name", "number", "integer",
	"yield_expr", "yield_arg", "trailer", "arguments", "arglist", "argument",
	"subscriptlist", "subscript", "sliceop", "comp_for", "comp_iter",
}
var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))

func init() {
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
}

type PythonParser struct {
	PythonBaseParser
}

func NewPythonParser(input antlr.TokenStream) *PythonParser {
	this := new(PythonParser)

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "PythonParser.g4"

	return this
}

// PythonParser tokens.
const (
	PythonParserEOF                = antlr.TokenEOF
	PythonParserINDENT             = 1
	PythonParserDEDENT             = 2
	PythonParserLINE_BREAK         = 3
	PythonParserDEF                = 4
	PythonParserRETURN             = 5
	PythonParserRAISE              = 6
	PythonParserFROM               = 7
	PythonParserIMPORT             = 8
	PythonParserNONLOCAL           = 9
	PythonParserAS                 = 10
	PythonParserGLOBAL             = 11
	PythonParserASSERT             = 12
	PythonParserIF                 = 13
	PythonParserELIF               = 14
	PythonParserELSE               = 15
	PythonParserWHILE              = 16
	PythonParserFOR                = 17
	PythonParserIN                 = 18
	PythonParserTRY                = 19
	PythonParserNONE               = 20
	PythonParserFINALLY            = 21
	PythonParserWITH               = 22
	PythonParserEXCEPT             = 23
	PythonParserLAMBDA             = 24
	PythonParserOR                 = 25
	PythonParserAND                = 26
	PythonParserNOT                = 27
	PythonParserIS                 = 28
	PythonParserCLASS              = 29
	PythonParserYIELD              = 30
	PythonParserDEL                = 31
	PythonParserPASS               = 32
	PythonParserCONTINUE           = 33
	PythonParserBREAK              = 34
	PythonParserASYNC              = 35
	PythonParserAWAIT              = 36
	PythonParserPRINT              = 37
	PythonParserEXEC               = 38
	PythonParserTRUE               = 39
	PythonParserFALSE              = 40
	PythonParserDOT                = 41
	PythonParserELLIPSIS           = 42
	PythonParserREVERSE_QUOTE      = 43
	PythonParserSTAR               = 44
	PythonParserCOMMA              = 45
	PythonParserCOLON              = 46
	PythonParserSEMI_COLON         = 47
	PythonParserPOWER              = 48
	PythonParserASSIGN             = 49
	PythonParserOR_OP              = 50
	PythonParserXOR                = 51
	PythonParserAND_OP             = 52
	PythonParserLEFT_SHIFT         = 53
	PythonParserRIGHT_SHIFT        = 54
	PythonParserADD                = 55
	PythonParserMINUS              = 56
	PythonParserDIV                = 57
	PythonParserMOD                = 58
	PythonParserIDIV               = 59
	PythonParserNOT_OP             = 60
	PythonParserLESS_THAN          = 61
	PythonParserGREATER_THAN       = 62
	PythonParserEQUALS             = 63
	PythonParserGT_EQ              = 64
	PythonParserLT_EQ              = 65
	PythonParserNOT_EQ_1           = 66
	PythonParserNOT_EQ_2           = 67
	PythonParserAT                 = 68
	PythonParserARROW              = 69
	PythonParserADD_ASSIGN         = 70
	PythonParserSUB_ASSIGN         = 71
	PythonParserMULT_ASSIGN        = 72
	PythonParserAT_ASSIGN          = 73
	PythonParserDIV_ASSIGN         = 74
	PythonParserMOD_ASSIGN         = 75
	PythonParserAND_ASSIGN         = 76
	PythonParserOR_ASSIGN          = 77
	PythonParserXOR_ASSIGN         = 78
	PythonParserLEFT_SHIFT_ASSIGN  = 79
	PythonParserRIGHT_SHIFT_ASSIGN = 80
	PythonParserPOWER_ASSIGN       = 81
	PythonParserIDIV_ASSIGN        = 82
	PythonParserSTRING             = 83
	PythonParserDECIMAL_INTEGER    = 84
	PythonParserOCT_INTEGER        = 85
	PythonParserHEX_INTEGER        = 86
	PythonParserBIN_INTEGER        = 87
	PythonParserIMAG_NUMBER        = 88
	PythonParserFLOAT_NUMBER       = 89
	PythonParserOPEN_PAREN         = 90
	PythonParserCLOSE_PAREN        = 91
	PythonParserOPEN_BRACE         = 92
	PythonParserCLOSE_BRACE        = 93
	PythonParserOPEN_BRACKET       = 94
	PythonParserCLOSE_BRACKET      = 95
	PythonParserNAME               = 96
	PythonParserLINE_JOIN          = 97
	PythonParserNEWLINE            = 98
	PythonParserWS                 = 99
	PythonParserCOMMENT            = 100
)

// PythonParser rules.
const (
	PythonParserRULE_root               = 0
	PythonParserRULE_single_input       = 1
	PythonParserRULE_file_input         = 2
	PythonParserRULE_eval_input         = 3
	PythonParserRULE_stmt               = 4
	PythonParserRULE_compound_stmt      = 5
	PythonParserRULE_suite              = 6
	PythonParserRULE_decorator          = 7
	PythonParserRULE_elif_clause        = 8
	PythonParserRULE_else_clause        = 9
	PythonParserRULE_finally_clause     = 10
	PythonParserRULE_with_item          = 11
	PythonParserRULE_except_clause      = 12
	PythonParserRULE_classdef           = 13
	PythonParserRULE_funcdef            = 14
	PythonParserRULE_typedargslist      = 15
	PythonParserRULE_args               = 16
	PythonParserRULE_kwargs             = 17
	PythonParserRULE_def_parameters     = 18
	PythonParserRULE_def_parameter      = 19
	PythonParserRULE_named_parameter    = 20
	PythonParserRULE_simple_stmt        = 21
	PythonParserRULE_small_stmt         = 22
	PythonParserRULE_from_stmt_source   = 23
	PythonParserRULE_from_stmt_as_names = 24
	PythonParserRULE_testlist_star_expr = 25
	PythonParserRULE_star_expr          = 26
	PythonParserRULE_assign_part        = 27
	PythonParserRULE_exprlist           = 28
	PythonParserRULE_import_as_names    = 29
	PythonParserRULE_import_as_name     = 30
	PythonParserRULE_dotted_as_names    = 31
	PythonParserRULE_dotted_as_name     = 32
	PythonParserRULE_test               = 33
	PythonParserRULE_varargslist        = 34
	PythonParserRULE_vardef_parameters  = 35
	PythonParserRULE_vardef_parameter   = 36
	PythonParserRULE_varargs            = 37
	PythonParserRULE_varkwargs          = 38
	PythonParserRULE_logical_test       = 39
	PythonParserRULE_comparison         = 40
	PythonParserRULE_expr               = 41
	PythonParserRULE_atom               = 42
	PythonParserRULE_dictorsetmaker     = 43
	PythonParserRULE_testlist_comp      = 44
	PythonParserRULE_testlist           = 45
	PythonParserRULE_dotted_name        = 46
	PythonParserRULE_name               = 47
	PythonParserRULE_number             = 48
	PythonParserRULE_integer            = 49
	PythonParserRULE_yield_expr         = 50
	PythonParserRULE_yield_arg          = 51
	PythonParserRULE_trailer            = 52
	PythonParserRULE_arguments          = 53
	PythonParserRULE_arglist            = 54
	PythonParserRULE_argument           = 55
	PythonParserRULE_subscriptlist      = 56
	PythonParserRULE_subscript          = 57
	PythonParserRULE_sliceop            = 58
	PythonParserRULE_comp_for           = 59
	PythonParserRULE_comp_iter          = 60
)

// IRootContext is an interface to support dynamic dispatch.
type IRootContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRootContext differentiates from other interfaces.
	IsRootContext()
}

type RootContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRootContext() *RootContext {
	var p = new(RootContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_root
	return p
}

func (*RootContext) IsRootContext() {}

func NewRootContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RootContext {
	var p = new(RootContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_root

	return p
}

func (s *RootContext) GetParser() antlr.Parser { return s.parser }

func (s *RootContext) EOF() antlr.TerminalNode {
	return s.GetToken(PythonParserEOF, 0)
}

func (s *RootContext) Single_input() ISingle_inputContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingle_inputContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingle_inputContext)
}

func (s *RootContext) File_input() IFile_inputContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFile_inputContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFile_inputContext)
}

func (s *RootContext) Eval_input() IEval_inputContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEval_inputContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEval_inputContext)
}

func (s *RootContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RootContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RootContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterRoot(s)
	}
}

func (s *RootContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitRoot(s)
	}
}

func (p *PythonParser) Root() (localctx IRootContext) {
	localctx = NewRootContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, PythonParserRULE_root)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(125)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 0, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(122)
			p.Single_input()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 0, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(123)
			p.File_input()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 0, p.GetParserRuleContext()) == 3 {
		{
			p.SetState(124)
			p.Eval_input()
		}

	}
	{
		p.SetState(127)
		p.Match(PythonParserEOF)
	}

	return localctx
}

// ISingle_inputContext is an interface to support dynamic dispatch.
type ISingle_inputContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSingle_inputContext differentiates from other interfaces.
	IsSingle_inputContext()
}

type Single_inputContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingle_inputContext() *Single_inputContext {
	var p = new(Single_inputContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_single_input
	return p
}

func (*Single_inputContext) IsSingle_inputContext() {}

func NewSingle_inputContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Single_inputContext {
	var p = new(Single_inputContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_single_input

	return p
}

func (s *Single_inputContext) GetParser() antlr.Parser { return s.parser }

func (s *Single_inputContext) LINE_BREAK() antlr.TerminalNode {
	return s.GetToken(PythonParserLINE_BREAK, 0)
}

func (s *Single_inputContext) Simple_stmt() ISimple_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_stmtContext)
}

func (s *Single_inputContext) Compound_stmt() ICompound_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompound_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompound_stmtContext)
}

func (s *Single_inputContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Single_inputContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Single_inputContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterSingle_input(s)
	}
}

func (s *Single_inputContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitSingle_input(s)
	}
}

func (p *PythonParser) Single_input() (localctx ISingle_inputContext) {
	localctx = NewSingle_inputContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, PythonParserRULE_single_input)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(134)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(129)
			p.Match(PythonParserLINE_BREAK)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(130)
			p.Simple_stmt()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(131)
			p.Compound_stmt()
		}
		{
			p.SetState(132)
			p.Match(PythonParserLINE_BREAK)
		}

	}

	return localctx
}

// IFile_inputContext is an interface to support dynamic dispatch.
type IFile_inputContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFile_inputContext differentiates from other interfaces.
	IsFile_inputContext()
}

type File_inputContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFile_inputContext() *File_inputContext {
	var p = new(File_inputContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_file_input
	return p
}

func (*File_inputContext) IsFile_inputContext() {}

func NewFile_inputContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *File_inputContext {
	var p = new(File_inputContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_file_input

	return p
}

func (s *File_inputContext) GetParser() antlr.Parser { return s.parser }

func (s *File_inputContext) AllLINE_BREAK() []antlr.TerminalNode {
	return s.GetTokens(PythonParserLINE_BREAK)
}

func (s *File_inputContext) LINE_BREAK(i int) antlr.TerminalNode {
	return s.GetToken(PythonParserLINE_BREAK, i)
}

func (s *File_inputContext) AllStmt() []IStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStmtContext)(nil)).Elem())
	var tst = make([]IStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStmtContext)
		}
	}

	return tst
}

func (s *File_inputContext) Stmt(i int) IStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStmtContext)
}

func (s *File_inputContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *File_inputContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *File_inputContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterFile_input(s)
	}
}

func (s *File_inputContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitFile_input(s)
	}
}

func (p *PythonParser) File_input() (localctx IFile_inputContext) {
	localctx = NewFile_inputContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, PythonParserRULE_file_input)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(138)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(138)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 2, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(136)
					p.Match(PythonParserLINE_BREAK)
				}

			case 2:
				{
					p.SetState(137)
					p.Stmt()
				}

			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(140)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext())
	}

	return localctx
}

// IEval_inputContext is an interface to support dynamic dispatch.
type IEval_inputContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEval_inputContext differentiates from other interfaces.
	IsEval_inputContext()
}

type Eval_inputContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEval_inputContext() *Eval_inputContext {
	var p = new(Eval_inputContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_eval_input
	return p
}

func (*Eval_inputContext) IsEval_inputContext() {}

func NewEval_inputContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Eval_inputContext {
	var p = new(Eval_inputContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_eval_input

	return p
}

func (s *Eval_inputContext) GetParser() antlr.Parser { return s.parser }

func (s *Eval_inputContext) Testlist() ITestlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestlistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestlistContext)
}

func (s *Eval_inputContext) AllLINE_BREAK() []antlr.TerminalNode {
	return s.GetTokens(PythonParserLINE_BREAK)
}

func (s *Eval_inputContext) LINE_BREAK(i int) antlr.TerminalNode {
	return s.GetToken(PythonParserLINE_BREAK, i)
}

func (s *Eval_inputContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Eval_inputContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Eval_inputContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterEval_input(s)
	}
}

func (s *Eval_inputContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitEval_input(s)
	}
}

func (p *PythonParser) Eval_input() (localctx IEval_inputContext) {
	localctx = NewEval_inputContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, PythonParserRULE_eval_input)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(142)
		p.Testlist()
	}
	p.SetState(146)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PythonParserLINE_BREAK {
		{
			p.SetState(143)
			p.Match(PythonParserLINE_BREAK)
		}

		p.SetState(148)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IStmtContext is an interface to support dynamic dispatch.
type IStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStmtContext differentiates from other interfaces.
	IsStmtContext()
}

type StmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStmtContext() *StmtContext {
	var p = new(StmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_stmt
	return p
}

func (*StmtContext) IsStmtContext() {}

func NewStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StmtContext {
	var p = new(StmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_stmt

	return p
}

func (s *StmtContext) GetParser() antlr.Parser { return s.parser }

func (s *StmtContext) Simple_stmt() ISimple_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_stmtContext)
}

func (s *StmtContext) Compound_stmt() ICompound_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompound_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompound_stmtContext)
}

func (s *StmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterStmt(s)
	}
}

func (s *StmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitStmt(s)
	}
}

func (p *PythonParser) Stmt() (localctx IStmtContext) {
	localctx = NewStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, PythonParserRULE_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(151)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 5, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(149)
			p.Simple_stmt()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(150)
			p.Compound_stmt()
		}

	}

	return localctx
}

// ICompound_stmtContext is an interface to support dynamic dispatch.
type ICompound_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCompound_stmtContext differentiates from other interfaces.
	IsCompound_stmtContext()
}

type Compound_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompound_stmtContext() *Compound_stmtContext {
	var p = new(Compound_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_compound_stmt
	return p
}

func (*Compound_stmtContext) IsCompound_stmtContext() {}

func NewCompound_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Compound_stmtContext {
	var p = new(Compound_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_compound_stmt

	return p
}

func (s *Compound_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Compound_stmtContext) CopyFrom(ctx *Compound_stmtContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *Compound_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Compound_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type While_stmtContext struct {
	*Compound_stmtContext
}

func NewWhile_stmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *While_stmtContext {
	var p = new(While_stmtContext)

	p.Compound_stmtContext = NewEmptyCompound_stmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*Compound_stmtContext))

	return p
}

func (s *While_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *While_stmtContext) WHILE() antlr.TerminalNode {
	return s.GetToken(PythonParserWHILE, 0)
}

func (s *While_stmtContext) Test() ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *While_stmtContext) COLON() antlr.TerminalNode {
	return s.GetToken(PythonParserCOLON, 0)
}

func (s *While_stmtContext) Suite() ISuiteContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISuiteContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISuiteContext)
}

func (s *While_stmtContext) Else_clause() IElse_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElse_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElse_clauseContext)
}

func (s *While_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterWhile_stmt(s)
	}
}

func (s *While_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitWhile_stmt(s)
	}
}

type Try_stmtContext struct {
	*Compound_stmtContext
}

func NewTry_stmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Try_stmtContext {
	var p = new(Try_stmtContext)

	p.Compound_stmtContext = NewEmptyCompound_stmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*Compound_stmtContext))

	return p
}

func (s *Try_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Try_stmtContext) TRY() antlr.TerminalNode {
	return s.GetToken(PythonParserTRY, 0)
}

func (s *Try_stmtContext) COLON() antlr.TerminalNode {
	return s.GetToken(PythonParserCOLON, 0)
}

func (s *Try_stmtContext) Suite() ISuiteContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISuiteContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISuiteContext)
}

func (s *Try_stmtContext) Finally_clause() IFinally_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFinally_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFinally_clauseContext)
}

func (s *Try_stmtContext) AllExcept_clause() []IExcept_clauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExcept_clauseContext)(nil)).Elem())
	var tst = make([]IExcept_clauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExcept_clauseContext)
		}
	}

	return tst
}

func (s *Try_stmtContext) Except_clause(i int) IExcept_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExcept_clauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExcept_clauseContext)
}

func (s *Try_stmtContext) Else_clause() IElse_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElse_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElse_clauseContext)
}

func (s *Try_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterTry_stmt(s)
	}
}

func (s *Try_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitTry_stmt(s)
	}
}

type If_stmtContext struct {
	*Compound_stmtContext
	cond ITestContext
}

func NewIf_stmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *If_stmtContext {
	var p = new(If_stmtContext)

	p.Compound_stmtContext = NewEmptyCompound_stmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*Compound_stmtContext))

	return p
}

func (s *If_stmtContext) GetCond() ITestContext { return s.cond }

func (s *If_stmtContext) SetCond(v ITestContext) { s.cond = v }

func (s *If_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_stmtContext) IF() antlr.TerminalNode {
	return s.GetToken(PythonParserIF, 0)
}

func (s *If_stmtContext) COLON() antlr.TerminalNode {
	return s.GetToken(PythonParserCOLON, 0)
}

func (s *If_stmtContext) Suite() ISuiteContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISuiteContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISuiteContext)
}

func (s *If_stmtContext) Test() ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *If_stmtContext) AllElif_clause() []IElif_clauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IElif_clauseContext)(nil)).Elem())
	var tst = make([]IElif_clauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IElif_clauseContext)
		}
	}

	return tst
}

func (s *If_stmtContext) Elif_clause(i int) IElif_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElif_clauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IElif_clauseContext)
}

func (s *If_stmtContext) Else_clause() IElse_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElse_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElse_clauseContext)
}

func (s *If_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterIf_stmt(s)
	}
}

func (s *If_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitIf_stmt(s)
	}
}

type With_stmtContext struct {
	*Compound_stmtContext
}

func NewWith_stmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *With_stmtContext {
	var p = new(With_stmtContext)

	p.Compound_stmtContext = NewEmptyCompound_stmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*Compound_stmtContext))

	return p
}

func (s *With_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *With_stmtContext) WITH() antlr.TerminalNode {
	return s.GetToken(PythonParserWITH, 0)
}

func (s *With_stmtContext) AllWith_item() []IWith_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWith_itemContext)(nil)).Elem())
	var tst = make([]IWith_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWith_itemContext)
		}
	}

	return tst
}

func (s *With_stmtContext) With_item(i int) IWith_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWith_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWith_itemContext)
}

func (s *With_stmtContext) COLON() antlr.TerminalNode {
	return s.GetToken(PythonParserCOLON, 0)
}

func (s *With_stmtContext) Suite() ISuiteContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISuiteContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISuiteContext)
}

func (s *With_stmtContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(PythonParserASYNC, 0)
}

func (s *With_stmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(PythonParserCOMMA)
}

func (s *With_stmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(PythonParserCOMMA, i)
}

func (s *With_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterWith_stmt(s)
	}
}

func (s *With_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitWith_stmt(s)
	}
}

type Class_or_func_def_stmtContext struct {
	*Compound_stmtContext
}

func NewClass_or_func_def_stmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Class_or_func_def_stmtContext {
	var p = new(Class_or_func_def_stmtContext)

	p.Compound_stmtContext = NewEmptyCompound_stmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*Compound_stmtContext))

	return p
}

func (s *Class_or_func_def_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Class_or_func_def_stmtContext) Classdef() IClassdefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassdefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassdefContext)
}

func (s *Class_or_func_def_stmtContext) Funcdef() IFuncdefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFuncdefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFuncdefContext)
}

func (s *Class_or_func_def_stmtContext) AllDecorator() []IDecoratorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDecoratorContext)(nil)).Elem())
	var tst = make([]IDecoratorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDecoratorContext)
		}
	}

	return tst
}

func (s *Class_or_func_def_stmtContext) Decorator(i int) IDecoratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDecoratorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDecoratorContext)
}

func (s *Class_or_func_def_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterClass_or_func_def_stmt(s)
	}
}

func (s *Class_or_func_def_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitClass_or_func_def_stmt(s)
	}
}

type For_stmtContext struct {
	*Compound_stmtContext
}

func NewFor_stmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *For_stmtContext {
	var p = new(For_stmtContext)

	p.Compound_stmtContext = NewEmptyCompound_stmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*Compound_stmtContext))

	return p
}

func (s *For_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *For_stmtContext) FOR() antlr.TerminalNode {
	return s.GetToken(PythonParserFOR, 0)
}

func (s *For_stmtContext) Exprlist() IExprlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprlistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprlistContext)
}

func (s *For_stmtContext) IN() antlr.TerminalNode {
	return s.GetToken(PythonParserIN, 0)
}

func (s *For_stmtContext) Testlist() ITestlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestlistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestlistContext)
}

func (s *For_stmtContext) COLON() antlr.TerminalNode {
	return s.GetToken(PythonParserCOLON, 0)
}

func (s *For_stmtContext) Suite() ISuiteContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISuiteContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISuiteContext)
}

func (s *For_stmtContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(PythonParserASYNC, 0)
}

func (s *For_stmtContext) Else_clause() IElse_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElse_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElse_clauseContext)
}

func (s *For_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterFor_stmt(s)
	}
}

func (s *For_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitFor_stmt(s)
	}
}

func (p *PythonParser) Compound_stmt() (localctx ICompound_stmtContext) {
	localctx = NewCompound_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, PythonParserRULE_compound_stmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(227)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 19, p.GetParserRuleContext()) {
	case 1:
		localctx = NewIf_stmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(153)
			p.Match(PythonParserIF)
		}
		{
			p.SetState(154)

			var _x = p.Test()

			localctx.(*If_stmtContext).cond = _x
		}
		{
			p.SetState(155)
			p.Match(PythonParserCOLON)
		}
		{
			p.SetState(156)
			p.Suite()
		}
		p.SetState(160)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(157)
					p.Elif_clause()
				}

			}
			p.SetState(162)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext())
		}
		p.SetState(164)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 7, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(163)
				p.Else_clause()
			}

		}

	case 2:
		localctx = NewWhile_stmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(166)
			p.Match(PythonParserWHILE)
		}
		{
			p.SetState(167)
			p.Test()
		}
		{
			p.SetState(168)
			p.Match(PythonParserCOLON)
		}
		{
			p.SetState(169)
			p.Suite()
		}
		p.SetState(171)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 8, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(170)
				p.Else_clause()
			}

		}

	case 3:
		localctx = NewFor_stmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(174)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PythonParserASYNC {
			{
				p.SetState(173)
				p.Match(PythonParserASYNC)
			}

		}
		{
			p.SetState(176)
			p.Match(PythonParserFOR)
		}
		{
			p.SetState(177)
			p.Exprlist()
		}
		{
			p.SetState(178)
			p.Match(PythonParserIN)
		}
		{
			p.SetState(179)
			p.Testlist()
		}
		{
			p.SetState(180)
			p.Match(PythonParserCOLON)
		}
		{
			p.SetState(181)
			p.Suite()
		}
		p.SetState(183)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 10, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(182)
				p.Else_clause()
			}

		}

	case 4:
		localctx = NewTry_stmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(185)
			p.Match(PythonParserTRY)
		}
		{
			p.SetState(186)
			p.Match(PythonParserCOLON)
		}
		{
			p.SetState(187)
			p.Suite()
		}
		p.SetState(200)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case PythonParserEXCEPT:
			p.SetState(189)
			p.GetErrorHandler().Sync(p)
			_alt = 1
			for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				switch _alt {
				case 1:
					{
						p.SetState(188)
						p.Except_clause()
					}

				default:
					panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				}

				p.SetState(191)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 11, p.GetParserRuleContext())
			}
			p.SetState(194)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(193)
					p.Else_clause()
				}

			}
			p.SetState(197)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 13, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(196)
					p.Finally_clause()
				}

			}

		case PythonParserFINALLY:
			{
				p.SetState(199)
				p.Finally_clause()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 5:
		localctx = NewWith_stmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		p.SetState(203)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PythonParserASYNC {
			{
				p.SetState(202)
				p.Match(PythonParserASYNC)
			}

		}
		{
			p.SetState(205)
			p.Match(PythonParserWITH)
		}
		{
			p.SetState(206)
			p.With_item()
		}
		p.SetState(211)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PythonParserCOMMA {
			{
				p.SetState(207)
				p.Match(PythonParserCOMMA)
			}
			{
				p.SetState(208)
				p.With_item()
			}

			p.SetState(213)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(214)
			p.Match(PythonParserCOLON)
		}
		{
			p.SetState(215)
			p.Suite()
		}

	case 6:
		localctx = NewClass_or_func_def_stmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		p.SetState(220)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PythonParserAT {
			{
				p.SetState(217)
				p.Decorator()
			}

			p.SetState(222)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(225)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case PythonParserCLASS:
			{
				p.SetState(223)
				p.Classdef()
			}

		case PythonParserDEF, PythonParserASYNC:
			{
				p.SetState(224)
				p.Funcdef()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	}

	return localctx
}

// ISuiteContext is an interface to support dynamic dispatch.
type ISuiteContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSuiteContext differentiates from other interfaces.
	IsSuiteContext()
}

type SuiteContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySuiteContext() *SuiteContext {
	var p = new(SuiteContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_suite
	return p
}

func (*SuiteContext) IsSuiteContext() {}

func NewSuiteContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SuiteContext {
	var p = new(SuiteContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_suite

	return p
}

func (s *SuiteContext) GetParser() antlr.Parser { return s.parser }

func (s *SuiteContext) Simple_stmt() ISimple_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_stmtContext)
}

func (s *SuiteContext) LINE_BREAK() antlr.TerminalNode {
	return s.GetToken(PythonParserLINE_BREAK, 0)
}

func (s *SuiteContext) INDENT() antlr.TerminalNode {
	return s.GetToken(PythonParserINDENT, 0)
}

func (s *SuiteContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(PythonParserDEDENT, 0)
}

func (s *SuiteContext) AllStmt() []IStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStmtContext)(nil)).Elem())
	var tst = make([]IStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStmtContext)
		}
	}

	return tst
}

func (s *SuiteContext) Stmt(i int) IStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStmtContext)
}

func (s *SuiteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SuiteContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SuiteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterSuite(s)
	}
}

func (s *SuiteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitSuite(s)
	}
}

func (p *PythonParser) Suite() (localctx ISuiteContext) {
	localctx = NewSuiteContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, PythonParserRULE_suite)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(239)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 21, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(229)
			p.Simple_stmt()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(230)
			p.Match(PythonParserLINE_BREAK)
		}
		{
			p.SetState(231)
			p.Match(PythonParserINDENT)
		}
		p.SetState(233)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(232)
					p.Stmt()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(235)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 20, p.GetParserRuleContext())
		}
		{
			p.SetState(237)
			p.Match(PythonParserDEDENT)
		}

	}

	return localctx
}

// IDecoratorContext is an interface to support dynamic dispatch.
type IDecoratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDecoratorContext differentiates from other interfaces.
	IsDecoratorContext()
}

type DecoratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecoratorContext() *DecoratorContext {
	var p = new(DecoratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_decorator
	return p
}

func (*DecoratorContext) IsDecoratorContext() {}

func NewDecoratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecoratorContext {
	var p = new(DecoratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_decorator

	return p
}

func (s *DecoratorContext) GetParser() antlr.Parser { return s.parser }

func (s *DecoratorContext) AT() antlr.TerminalNode {
	return s.GetToken(PythonParserAT, 0)
}

func (s *DecoratorContext) Dotted_name() IDotted_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDotted_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDotted_nameContext)
}

func (s *DecoratorContext) LINE_BREAK() antlr.TerminalNode {
	return s.GetToken(PythonParserLINE_BREAK, 0)
}

func (s *DecoratorContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(PythonParserOPEN_PAREN, 0)
}

func (s *DecoratorContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(PythonParserCLOSE_PAREN, 0)
}

func (s *DecoratorContext) Arglist() IArglistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArglistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArglistContext)
}

func (s *DecoratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecoratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecoratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterDecorator(s)
	}
}

func (s *DecoratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitDecorator(s)
	}
}

func (p *PythonParser) Decorator() (localctx IDecoratorContext) {
	localctx = NewDecoratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, PythonParserRULE_decorator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(241)
		p.Match(PythonParserAT)
	}
	{
		p.SetState(242)
		p.dotted_name(0)
	}
	p.SetState(248)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PythonParserOPEN_PAREN {
		{
			p.SetState(243)
			p.Match(PythonParserOPEN_PAREN)
		}
		p.SetState(245)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PythonParserNONE)|(1<<PythonParserLAMBDA)|(1<<PythonParserNOT))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(PythonParserAWAIT-36))|(1<<(PythonParserPRINT-36))|(1<<(PythonParserEXEC-36))|(1<<(PythonParserTRUE-36))|(1<<(PythonParserFALSE-36))|(1<<(PythonParserELLIPSIS-36))|(1<<(PythonParserREVERSE_QUOTE-36))|(1<<(PythonParserSTAR-36))|(1<<(PythonParserPOWER-36))|(1<<(PythonParserADD-36))|(1<<(PythonParserMINUS-36))|(1<<(PythonParserNOT_OP-36)))) != 0) || (((_la-83)&-(0x1f+1)) == 0 && ((1<<uint((_la-83)))&((1<<(PythonParserSTRING-83))|(1<<(PythonParserDECIMAL_INTEGER-83))|(1<<(PythonParserOCT_INTEGER-83))|(1<<(PythonParserHEX_INTEGER-83))|(1<<(PythonParserBIN_INTEGER-83))|(1<<(PythonParserIMAG_NUMBER-83))|(1<<(PythonParserFLOAT_NUMBER-83))|(1<<(PythonParserOPEN_PAREN-83))|(1<<(PythonParserOPEN_BRACE-83))|(1<<(PythonParserOPEN_BRACKET-83))|(1<<(PythonParserNAME-83)))) != 0) {
			{
				p.SetState(244)
				p.Arglist()
			}

		}
		{
			p.SetState(247)
			p.Match(PythonParserCLOSE_PAREN)
		}

	}
	{
		p.SetState(250)
		p.Match(PythonParserLINE_BREAK)
	}

	return localctx
}

// IElif_clauseContext is an interface to support dynamic dispatch.
type IElif_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElif_clauseContext differentiates from other interfaces.
	IsElif_clauseContext()
}

type Elif_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElif_clauseContext() *Elif_clauseContext {
	var p = new(Elif_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_elif_clause
	return p
}

func (*Elif_clauseContext) IsElif_clauseContext() {}

func NewElif_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Elif_clauseContext {
	var p = new(Elif_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_elif_clause

	return p
}

func (s *Elif_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Elif_clauseContext) ELIF() antlr.TerminalNode {
	return s.GetToken(PythonParserELIF, 0)
}

func (s *Elif_clauseContext) Test() ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Elif_clauseContext) COLON() antlr.TerminalNode {
	return s.GetToken(PythonParserCOLON, 0)
}

func (s *Elif_clauseContext) Suite() ISuiteContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISuiteContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISuiteContext)
}

func (s *Elif_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Elif_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Elif_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterElif_clause(s)
	}
}

func (s *Elif_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitElif_clause(s)
	}
}

func (p *PythonParser) Elif_clause() (localctx IElif_clauseContext) {
	localctx = NewElif_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, PythonParserRULE_elif_clause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(252)
		p.Match(PythonParserELIF)
	}
	{
		p.SetState(253)
		p.Test()
	}
	{
		p.SetState(254)
		p.Match(PythonParserCOLON)
	}
	{
		p.SetState(255)
		p.Suite()
	}

	return localctx
}

// IElse_clauseContext is an interface to support dynamic dispatch.
type IElse_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElse_clauseContext differentiates from other interfaces.
	IsElse_clauseContext()
}

type Else_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElse_clauseContext() *Else_clauseContext {
	var p = new(Else_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_else_clause
	return p
}

func (*Else_clauseContext) IsElse_clauseContext() {}

func NewElse_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Else_clauseContext {
	var p = new(Else_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_else_clause

	return p
}

func (s *Else_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Else_clauseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(PythonParserELSE, 0)
}

func (s *Else_clauseContext) COLON() antlr.TerminalNode {
	return s.GetToken(PythonParserCOLON, 0)
}

func (s *Else_clauseContext) Suite() ISuiteContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISuiteContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISuiteContext)
}

func (s *Else_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Else_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Else_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterElse_clause(s)
	}
}

func (s *Else_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitElse_clause(s)
	}
}

func (p *PythonParser) Else_clause() (localctx IElse_clauseContext) {
	localctx = NewElse_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, PythonParserRULE_else_clause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(257)
		p.Match(PythonParserELSE)
	}
	{
		p.SetState(258)
		p.Match(PythonParserCOLON)
	}
	{
		p.SetState(259)
		p.Suite()
	}

	return localctx
}

// IFinally_clauseContext is an interface to support dynamic dispatch.
type IFinally_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFinally_clauseContext differentiates from other interfaces.
	IsFinally_clauseContext()
}

type Finally_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFinally_clauseContext() *Finally_clauseContext {
	var p = new(Finally_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_finally_clause
	return p
}

func (*Finally_clauseContext) IsFinally_clauseContext() {}

func NewFinally_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Finally_clauseContext {
	var p = new(Finally_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_finally_clause

	return p
}

func (s *Finally_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Finally_clauseContext) FINALLY() antlr.TerminalNode {
	return s.GetToken(PythonParserFINALLY, 0)
}

func (s *Finally_clauseContext) COLON() antlr.TerminalNode {
	return s.GetToken(PythonParserCOLON, 0)
}

func (s *Finally_clauseContext) Suite() ISuiteContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISuiteContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISuiteContext)
}

func (s *Finally_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Finally_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Finally_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterFinally_clause(s)
	}
}

func (s *Finally_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitFinally_clause(s)
	}
}

func (p *PythonParser) Finally_clause() (localctx IFinally_clauseContext) {
	localctx = NewFinally_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, PythonParserRULE_finally_clause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(261)
		p.Match(PythonParserFINALLY)
	}
	{
		p.SetState(262)
		p.Match(PythonParserCOLON)
	}
	{
		p.SetState(263)
		p.Suite()
	}

	return localctx
}

// IWith_itemContext is an interface to support dynamic dispatch.
type IWith_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWith_itemContext differentiates from other interfaces.
	IsWith_itemContext()
}

type With_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWith_itemContext() *With_itemContext {
	var p = new(With_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_with_item
	return p
}

func (*With_itemContext) IsWith_itemContext() {}

func NewWith_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *With_itemContext {
	var p = new(With_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_with_item

	return p
}

func (s *With_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *With_itemContext) Test() ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *With_itemContext) AS() antlr.TerminalNode {
	return s.GetToken(PythonParserAS, 0)
}

func (s *With_itemContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *With_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *With_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *With_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterWith_item(s)
	}
}

func (s *With_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitWith_item(s)
	}
}

func (p *PythonParser) With_item() (localctx IWith_itemContext) {
	localctx = NewWith_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, PythonParserRULE_with_item)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(265)
		p.Test()
	}
	p.SetState(268)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PythonParserAS {
		{
			p.SetState(266)
			p.Match(PythonParserAS)
		}
		{
			p.SetState(267)
			p.expr(0)
		}

	}

	return localctx
}

// IExcept_clauseContext is an interface to support dynamic dispatch.
type IExcept_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExcept_clauseContext differentiates from other interfaces.
	IsExcept_clauseContext()
}

type Except_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExcept_clauseContext() *Except_clauseContext {
	var p = new(Except_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_except_clause
	return p
}

func (*Except_clauseContext) IsExcept_clauseContext() {}

func NewExcept_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Except_clauseContext {
	var p = new(Except_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_except_clause

	return p
}

func (s *Except_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Except_clauseContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(PythonParserEXCEPT, 0)
}

func (s *Except_clauseContext) COLON() antlr.TerminalNode {
	return s.GetToken(PythonParserCOLON, 0)
}

func (s *Except_clauseContext) Suite() ISuiteContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISuiteContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISuiteContext)
}

func (s *Except_clauseContext) Test() ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Except_clauseContext) COMMA() antlr.TerminalNode {
	return s.GetToken(PythonParserCOMMA, 0)
}

func (s *Except_clauseContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Except_clauseContext) AS() antlr.TerminalNode {
	return s.GetToken(PythonParserAS, 0)
}

func (s *Except_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Except_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Except_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterExcept_clause(s)
	}
}

func (s *Except_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitExcept_clause(s)
	}
}

func (p *PythonParser) Except_clause() (localctx IExcept_clauseContext) {
	localctx = NewExcept_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, PythonParserRULE_except_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(270)
		p.Match(PythonParserEXCEPT)
	}
	p.SetState(284)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PythonParserNONE)|(1<<PythonParserLAMBDA)|(1<<PythonParserNOT))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(PythonParserAWAIT-36))|(1<<(PythonParserPRINT-36))|(1<<(PythonParserEXEC-36))|(1<<(PythonParserTRUE-36))|(1<<(PythonParserFALSE-36))|(1<<(PythonParserELLIPSIS-36))|(1<<(PythonParserREVERSE_QUOTE-36))|(1<<(PythonParserADD-36))|(1<<(PythonParserMINUS-36))|(1<<(PythonParserNOT_OP-36)))) != 0) || (((_la-83)&-(0x1f+1)) == 0 && ((1<<uint((_la-83)))&((1<<(PythonParserSTRING-83))|(1<<(PythonParserDECIMAL_INTEGER-83))|(1<<(PythonParserOCT_INTEGER-83))|(1<<(PythonParserHEX_INTEGER-83))|(1<<(PythonParserBIN_INTEGER-83))|(1<<(PythonParserIMAG_NUMBER-83))|(1<<(PythonParserFLOAT_NUMBER-83))|(1<<(PythonParserOPEN_PAREN-83))|(1<<(PythonParserOPEN_BRACE-83))|(1<<(PythonParserOPEN_BRACKET-83))|(1<<(PythonParserNAME-83)))) != 0) {
		{
			p.SetState(271)
			p.Test()
		}
		p.SetState(282)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 25, p.GetParserRuleContext()) == 1 {
			p.SetState(272)

			if !(p.CheckVersion(2)) {
				panic(antlr.NewFailedPredicateException(p, "p.CheckVersion(2)", ""))
			}
			{
				p.SetState(273)
				p.Match(PythonParserCOMMA)
			}
			{
				p.SetState(274)
				p.Name()
			}
			p.SetVersion(2)

		} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 25, p.GetParserRuleContext()) == 2 {
			p.SetState(277)

			if !(p.CheckVersion(3)) {
				panic(antlr.NewFailedPredicateException(p, "p.CheckVersion(3)", ""))
			}
			{
				p.SetState(278)
				p.Match(PythonParserAS)
			}
			{
				p.SetState(279)
				p.Name()
			}
			p.SetVersion(3)

		}

	}
	{
		p.SetState(286)
		p.Match(PythonParserCOLON)
	}
	{
		p.SetState(287)
		p.Suite()
	}

	return localctx
}

// IClassdefContext is an interface to support dynamic dispatch.
type IClassdefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassdefContext differentiates from other interfaces.
	IsClassdefContext()
}

type ClassdefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassdefContext() *ClassdefContext {
	var p = new(ClassdefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_classdef
	return p
}

func (*ClassdefContext) IsClassdefContext() {}

func NewClassdefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassdefContext {
	var p = new(ClassdefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_classdef

	return p
}

func (s *ClassdefContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassdefContext) CLASS() antlr.TerminalNode {
	return s.GetToken(PythonParserCLASS, 0)
}

func (s *ClassdefContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *ClassdefContext) COLON() antlr.TerminalNode {
	return s.GetToken(PythonParserCOLON, 0)
}

func (s *ClassdefContext) Suite() ISuiteContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISuiteContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISuiteContext)
}

func (s *ClassdefContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(PythonParserOPEN_PAREN, 0)
}

func (s *ClassdefContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(PythonParserCLOSE_PAREN, 0)
}

func (s *ClassdefContext) Arglist() IArglistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArglistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArglistContext)
}

func (s *ClassdefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassdefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassdefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterClassdef(s)
	}
}

func (s *ClassdefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitClassdef(s)
	}
}

func (p *PythonParser) Classdef() (localctx IClassdefContext) {
	localctx = NewClassdefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, PythonParserRULE_classdef)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(289)
		p.Match(PythonParserCLASS)
	}
	{
		p.SetState(290)
		p.Name()
	}
	p.SetState(296)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PythonParserOPEN_PAREN {
		{
			p.SetState(291)
			p.Match(PythonParserOPEN_PAREN)
		}
		p.SetState(293)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PythonParserNONE)|(1<<PythonParserLAMBDA)|(1<<PythonParserNOT))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(PythonParserAWAIT-36))|(1<<(PythonParserPRINT-36))|(1<<(PythonParserEXEC-36))|(1<<(PythonParserTRUE-36))|(1<<(PythonParserFALSE-36))|(1<<(PythonParserELLIPSIS-36))|(1<<(PythonParserREVERSE_QUOTE-36))|(1<<(PythonParserSTAR-36))|(1<<(PythonParserPOWER-36))|(1<<(PythonParserADD-36))|(1<<(PythonParserMINUS-36))|(1<<(PythonParserNOT_OP-36)))) != 0) || (((_la-83)&-(0x1f+1)) == 0 && ((1<<uint((_la-83)))&((1<<(PythonParserSTRING-83))|(1<<(PythonParserDECIMAL_INTEGER-83))|(1<<(PythonParserOCT_INTEGER-83))|(1<<(PythonParserHEX_INTEGER-83))|(1<<(PythonParserBIN_INTEGER-83))|(1<<(PythonParserIMAG_NUMBER-83))|(1<<(PythonParserFLOAT_NUMBER-83))|(1<<(PythonParserOPEN_PAREN-83))|(1<<(PythonParserOPEN_BRACE-83))|(1<<(PythonParserOPEN_BRACKET-83))|(1<<(PythonParserNAME-83)))) != 0) {
			{
				p.SetState(292)
				p.Arglist()
			}

		}
		{
			p.SetState(295)
			p.Match(PythonParserCLOSE_PAREN)
		}

	}
	{
		p.SetState(298)
		p.Match(PythonParserCOLON)
	}
	{
		p.SetState(299)
		p.Suite()
	}

	return localctx
}

// IFuncdefContext is an interface to support dynamic dispatch.
type IFuncdefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFuncdefContext differentiates from other interfaces.
	IsFuncdefContext()
}

type FuncdefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFuncdefContext() *FuncdefContext {
	var p = new(FuncdefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_funcdef
	return p
}

func (*FuncdefContext) IsFuncdefContext() {}

func NewFuncdefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FuncdefContext {
	var p = new(FuncdefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_funcdef

	return p
}

func (s *FuncdefContext) GetParser() antlr.Parser { return s.parser }

func (s *FuncdefContext) DEF() antlr.TerminalNode {
	return s.GetToken(PythonParserDEF, 0)
}

func (s *FuncdefContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *FuncdefContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(PythonParserOPEN_PAREN, 0)
}

func (s *FuncdefContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(PythonParserCLOSE_PAREN, 0)
}

func (s *FuncdefContext) COLON() antlr.TerminalNode {
	return s.GetToken(PythonParserCOLON, 0)
}

func (s *FuncdefContext) Suite() ISuiteContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISuiteContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISuiteContext)
}

func (s *FuncdefContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(PythonParserASYNC, 0)
}

func (s *FuncdefContext) Typedargslist() ITypedargslistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypedargslistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypedargslistContext)
}

func (s *FuncdefContext) ARROW() antlr.TerminalNode {
	return s.GetToken(PythonParserARROW, 0)
}

func (s *FuncdefContext) Test() ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *FuncdefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FuncdefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FuncdefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterFuncdef(s)
	}
}

func (s *FuncdefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitFuncdef(s)
	}
}

func (p *PythonParser) Funcdef() (localctx IFuncdefContext) {
	localctx = NewFuncdefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, PythonParserRULE_funcdef)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(302)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PythonParserASYNC {
		{
			p.SetState(301)
			p.Match(PythonParserASYNC)
		}

	}
	{
		p.SetState(304)
		p.Match(PythonParserDEF)
	}
	{
		p.SetState(305)
		p.Name()
	}
	{
		p.SetState(306)
		p.Match(PythonParserOPEN_PAREN)
	}
	p.SetState(308)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-39)&-(0x1f+1)) == 0 && ((1<<uint((_la-39)))&((1<<(PythonParserTRUE-39))|(1<<(PythonParserFALSE-39))|(1<<(PythonParserSTAR-39))|(1<<(PythonParserPOWER-39)))) != 0) || _la == PythonParserNAME {
		{
			p.SetState(307)
			p.Typedargslist()
		}

	}
	{
		p.SetState(310)
		p.Match(PythonParserCLOSE_PAREN)
	}
	p.SetState(313)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PythonParserARROW {
		{
			p.SetState(311)
			p.Match(PythonParserARROW)
		}
		{
			p.SetState(312)
			p.Test()
		}

	}
	{
		p.SetState(315)
		p.Match(PythonParserCOLON)
	}
	{
		p.SetState(316)
		p.Suite()
	}

	return localctx
}

// ITypedargslistContext is an interface to support dynamic dispatch.
type ITypedargslistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypedargslistContext differentiates from other interfaces.
	IsTypedargslistContext()
}

type TypedargslistContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypedargslistContext() *TypedargslistContext {
	var p = new(TypedargslistContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_typedargslist
	return p
}

func (*TypedargslistContext) IsTypedargslistContext() {}

func NewTypedargslistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypedargslistContext {
	var p = new(TypedargslistContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_typedargslist

	return p
}

func (s *TypedargslistContext) GetParser() antlr.Parser { return s.parser }

func (s *TypedargslistContext) Args() IArgsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgsContext)
}

func (s *TypedargslistContext) Kwargs() IKwargsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IKwargsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IKwargsContext)
}

func (s *TypedargslistContext) AllDef_parameters() []IDef_parametersContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDef_parametersContext)(nil)).Elem())
	var tst = make([]IDef_parametersContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDef_parametersContext)
		}
	}

	return tst
}

func (s *TypedargslistContext) Def_parameters(i int) IDef_parametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDef_parametersContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDef_parametersContext)
}

func (s *TypedargslistContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(PythonParserCOMMA)
}

func (s *TypedargslistContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(PythonParserCOMMA, i)
}

func (s *TypedargslistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypedargslistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypedargslistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterTypedargslist(s)
	}
}

func (s *TypedargslistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitTypedargslist(s)
	}
}

func (p *PythonParser) Typedargslist() (localctx ITypedargslistContext) {
	localctx = NewTypedargslistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, PythonParserRULE_typedargslist)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(342)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 38, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(321)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 32, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(318)
				p.Def_parameters()
			}
			{
				p.SetState(319)
				p.Match(PythonParserCOMMA)
			}

		}
		p.SetState(333)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case PythonParserSTAR:
			{
				p.SetState(323)
				p.Args()
			}
			p.SetState(326)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 33, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(324)
					p.Match(PythonParserCOMMA)
				}
				{
					p.SetState(325)
					p.Def_parameters()
				}

			}
			p.SetState(330)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 34, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(328)
					p.Match(PythonParserCOMMA)
				}
				{
					p.SetState(329)
					p.Kwargs()
				}

			}

		case PythonParserPOWER:
			{
				p.SetState(332)
				p.Kwargs()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		p.SetState(336)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PythonParserCOMMA {
			{
				p.SetState(335)
				p.Match(PythonParserCOMMA)
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(338)
			p.Def_parameters()
		}
		p.SetState(340)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PythonParserCOMMA {
			{
				p.SetState(339)
				p.Match(PythonParserCOMMA)
			}

		}

	}

	return localctx
}

// IArgsContext is an interface to support dynamic dispatch.
type IArgsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgsContext differentiates from other interfaces.
	IsArgsContext()
}

type ArgsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgsContext() *ArgsContext {
	var p = new(ArgsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_args
	return p
}

func (*ArgsContext) IsArgsContext() {}

func NewArgsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgsContext {
	var p = new(ArgsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_args

	return p
}

func (s *ArgsContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgsContext) STAR() antlr.TerminalNode {
	return s.GetToken(PythonParserSTAR, 0)
}

func (s *ArgsContext) Named_parameter() INamed_parameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamed_parameterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamed_parameterContext)
}

func (s *ArgsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterArgs(s)
	}
}

func (s *ArgsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitArgs(s)
	}
}

func (p *PythonParser) Args() (localctx IArgsContext) {
	localctx = NewArgsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, PythonParserRULE_args)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(344)
		p.Match(PythonParserSTAR)
	}
	{
		p.SetState(345)
		p.Named_parameter()
	}

	return localctx
}

// IKwargsContext is an interface to support dynamic dispatch.
type IKwargsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsKwargsContext differentiates from other interfaces.
	IsKwargsContext()
}

type KwargsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwargsContext() *KwargsContext {
	var p = new(KwargsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_kwargs
	return p
}

func (*KwargsContext) IsKwargsContext() {}

func NewKwargsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwargsContext {
	var p = new(KwargsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_kwargs

	return p
}

func (s *KwargsContext) GetParser() antlr.Parser { return s.parser }

func (s *KwargsContext) POWER() antlr.TerminalNode {
	return s.GetToken(PythonParserPOWER, 0)
}

func (s *KwargsContext) Named_parameter() INamed_parameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamed_parameterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamed_parameterContext)
}

func (s *KwargsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwargsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwargsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterKwargs(s)
	}
}

func (s *KwargsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitKwargs(s)
	}
}

func (p *PythonParser) Kwargs() (localctx IKwargsContext) {
	localctx = NewKwargsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, PythonParserRULE_kwargs)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(347)
		p.Match(PythonParserPOWER)
	}
	{
		p.SetState(348)
		p.Named_parameter()
	}

	return localctx
}

// IDef_parametersContext is an interface to support dynamic dispatch.
type IDef_parametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDef_parametersContext differentiates from other interfaces.
	IsDef_parametersContext()
}

type Def_parametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDef_parametersContext() *Def_parametersContext {
	var p = new(Def_parametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_def_parameters
	return p
}

func (*Def_parametersContext) IsDef_parametersContext() {}

func NewDef_parametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Def_parametersContext {
	var p = new(Def_parametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_def_parameters

	return p
}

func (s *Def_parametersContext) GetParser() antlr.Parser { return s.parser }

func (s *Def_parametersContext) AllDef_parameter() []IDef_parameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDef_parameterContext)(nil)).Elem())
	var tst = make([]IDef_parameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDef_parameterContext)
		}
	}

	return tst
}

func (s *Def_parametersContext) Def_parameter(i int) IDef_parameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDef_parameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDef_parameterContext)
}

func (s *Def_parametersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(PythonParserCOMMA)
}

func (s *Def_parametersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(PythonParserCOMMA, i)
}

func (s *Def_parametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Def_parametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Def_parametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterDef_parameters(s)
	}
}

func (s *Def_parametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitDef_parameters(s)
	}
}

func (p *PythonParser) Def_parameters() (localctx IDef_parametersContext) {
	localctx = NewDef_parametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, PythonParserRULE_def_parameters)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(350)
		p.Def_parameter()
	}
	p.SetState(355)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 39, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(351)
				p.Match(PythonParserCOMMA)
			}
			{
				p.SetState(352)
				p.Def_parameter()
			}

		}
		p.SetState(357)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 39, p.GetParserRuleContext())
	}

	return localctx
}

// IDef_parameterContext is an interface to support dynamic dispatch.
type IDef_parameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDef_parameterContext differentiates from other interfaces.
	IsDef_parameterContext()
}

type Def_parameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDef_parameterContext() *Def_parameterContext {
	var p = new(Def_parameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_def_parameter
	return p
}

func (*Def_parameterContext) IsDef_parameterContext() {}

func NewDef_parameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Def_parameterContext {
	var p = new(Def_parameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_def_parameter

	return p
}

func (s *Def_parameterContext) GetParser() antlr.Parser { return s.parser }

func (s *Def_parameterContext) Named_parameter() INamed_parameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamed_parameterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamed_parameterContext)
}

func (s *Def_parameterContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(PythonParserASSIGN, 0)
}

func (s *Def_parameterContext) Test() ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Def_parameterContext) STAR() antlr.TerminalNode {
	return s.GetToken(PythonParserSTAR, 0)
}

func (s *Def_parameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Def_parameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Def_parameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterDef_parameter(s)
	}
}

func (s *Def_parameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitDef_parameter(s)
	}
}

func (p *PythonParser) Def_parameter() (localctx IDef_parameterContext) {
	localctx = NewDef_parameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, PythonParserRULE_def_parameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(364)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PythonParserTRUE, PythonParserFALSE, PythonParserNAME:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(358)
			p.Named_parameter()
		}
		p.SetState(361)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PythonParserASSIGN {
			{
				p.SetState(359)
				p.Match(PythonParserASSIGN)
			}
			{
				p.SetState(360)
				p.Test()
			}

		}

	case PythonParserSTAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(363)
			p.Match(PythonParserSTAR)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// INamed_parameterContext is an interface to support dynamic dispatch.
type INamed_parameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamed_parameterContext differentiates from other interfaces.
	IsNamed_parameterContext()
}

type Named_parameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamed_parameterContext() *Named_parameterContext {
	var p = new(Named_parameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_named_parameter
	return p
}

func (*Named_parameterContext) IsNamed_parameterContext() {}

func NewNamed_parameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Named_parameterContext {
	var p = new(Named_parameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_named_parameter

	return p
}

func (s *Named_parameterContext) GetParser() antlr.Parser { return s.parser }

func (s *Named_parameterContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Named_parameterContext) COLON() antlr.TerminalNode {
	return s.GetToken(PythonParserCOLON, 0)
}

func (s *Named_parameterContext) Test() ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Named_parameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Named_parameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Named_parameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterNamed_parameter(s)
	}
}

func (s *Named_parameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitNamed_parameter(s)
	}
}

func (p *PythonParser) Named_parameter() (localctx INamed_parameterContext) {
	localctx = NewNamed_parameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, PythonParserRULE_named_parameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(366)
		p.Name()
	}
	p.SetState(369)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PythonParserCOLON {
		{
			p.SetState(367)
			p.Match(PythonParserCOLON)
		}
		{
			p.SetState(368)
			p.Test()
		}

	}

	return localctx
}

// ISimple_stmtContext is an interface to support dynamic dispatch.
type ISimple_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimple_stmtContext differentiates from other interfaces.
	IsSimple_stmtContext()
}

type Simple_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_stmtContext() *Simple_stmtContext {
	var p = new(Simple_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_simple_stmt
	return p
}

func (*Simple_stmtContext) IsSimple_stmtContext() {}

func NewSimple_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_stmtContext {
	var p = new(Simple_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_simple_stmt

	return p
}

func (s *Simple_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_stmtContext) AllSmall_stmt() []ISmall_stmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISmall_stmtContext)(nil)).Elem())
	var tst = make([]ISmall_stmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISmall_stmtContext)
		}
	}

	return tst
}

func (s *Simple_stmtContext) Small_stmt(i int) ISmall_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISmall_stmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISmall_stmtContext)
}

func (s *Simple_stmtContext) LINE_BREAK() antlr.TerminalNode {
	return s.GetToken(PythonParserLINE_BREAK, 0)
}

func (s *Simple_stmtContext) EOF() antlr.TerminalNode {
	return s.GetToken(PythonParserEOF, 0)
}

func (s *Simple_stmtContext) AllSEMI_COLON() []antlr.TerminalNode {
	return s.GetTokens(PythonParserSEMI_COLON)
}

func (s *Simple_stmtContext) SEMI_COLON(i int) antlr.TerminalNode {
	return s.GetToken(PythonParserSEMI_COLON, i)
}

func (s *Simple_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simple_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterSimple_stmt(s)
	}
}

func (s *Simple_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitSimple_stmt(s)
	}
}

func (p *PythonParser) Simple_stmt() (localctx ISimple_stmtContext) {
	localctx = NewSimple_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, PythonParserRULE_simple_stmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(371)
		p.Small_stmt()
	}
	p.SetState(376)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(372)
				p.Match(PythonParserSEMI_COLON)
			}
			{
				p.SetState(373)
				p.Small_stmt()
			}

		}
		p.SetState(378)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext())
	}
	p.SetState(380)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PythonParserSEMI_COLON {
		{
			p.SetState(379)
			p.Match(PythonParserSEMI_COLON)
		}

	}
	{
		p.SetState(382)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PythonParserEOF || _la == PythonParserLINE_BREAK) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ISmall_stmtContext is an interface to support dynamic dispatch.
type ISmall_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSmall_stmtContext differentiates from other interfaces.
	IsSmall_stmtContext()
}

type Small_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySmall_stmtContext() *Small_stmtContext {
	var p = new(Small_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_small_stmt
	return p
}

func (*Small_stmtContext) IsSmall_stmtContext() {}

func NewSmall_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Small_stmtContext {
	var p = new(Small_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_small_stmt

	return p
}

func (s *Small_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Small_stmtContext) CopyFrom(ctx *Small_stmtContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *Small_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Small_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Assert_stmtContext struct {
	*Small_stmtContext
}

func NewAssert_stmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Assert_stmtContext {
	var p = new(Assert_stmtContext)

	p.Small_stmtContext = NewEmptySmall_stmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*Small_stmtContext))

	return p
}

func (s *Assert_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assert_stmtContext) ASSERT() antlr.TerminalNode {
	return s.GetToken(PythonParserASSERT, 0)
}

func (s *Assert_stmtContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *Assert_stmtContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Assert_stmtContext) COMMA() antlr.TerminalNode {
	return s.GetToken(PythonParserCOMMA, 0)
}

func (s *Assert_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterAssert_stmt(s)
	}
}

func (s *Assert_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitAssert_stmt(s)
	}
}

type Nonlocal_stmtContext struct {
	*Small_stmtContext
}

func NewNonlocal_stmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Nonlocal_stmtContext {
	var p = new(Nonlocal_stmtContext)

	p.Small_stmtContext = NewEmptySmall_stmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*Small_stmtContext))

	return p
}

func (s *Nonlocal_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Nonlocal_stmtContext) NONLOCAL() antlr.TerminalNode {
	return s.GetToken(PythonParserNONLOCAL, 0)
}

func (s *Nonlocal_stmtContext) AllName() []INameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INameContext)(nil)).Elem())
	var tst = make([]INameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INameContext)
		}
	}

	return tst
}

func (s *Nonlocal_stmtContext) Name(i int) INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Nonlocal_stmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(PythonParserCOMMA)
}

func (s *Nonlocal_stmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(PythonParserCOMMA, i)
}

func (s *Nonlocal_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterNonlocal_stmt(s)
	}
}

func (s *Nonlocal_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitNonlocal_stmt(s)
	}
}

type Pass_stmtContext struct {
	*Small_stmtContext
}

func NewPass_stmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Pass_stmtContext {
	var p = new(Pass_stmtContext)

	p.Small_stmtContext = NewEmptySmall_stmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*Small_stmtContext))

	return p
}

func (s *Pass_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pass_stmtContext) PASS() antlr.TerminalNode {
	return s.GetToken(PythonParserPASS, 0)
}

func (s *Pass_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterPass_stmt(s)
	}
}

func (s *Pass_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitPass_stmt(s)
	}
}

type Import_stmtContext struct {
	*Small_stmtContext
}

func NewImport_stmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Import_stmtContext {
	var p = new(Import_stmtContext)

	p.Small_stmtContext = NewEmptySmall_stmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*Small_stmtContext))

	return p
}

func (s *Import_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Import_stmtContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(PythonParserIMPORT, 0)
}

func (s *Import_stmtContext) Dotted_as_names() IDotted_as_namesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDotted_as_namesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDotted_as_namesContext)
}

func (s *Import_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterImport_stmt(s)
	}
}

func (s *Import_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitImport_stmt(s)
	}
}

type Expr_stmtContext struct {
	*Small_stmtContext
}

func NewExpr_stmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Expr_stmtContext {
	var p = new(Expr_stmtContext)

	p.Small_stmtContext = NewEmptySmall_stmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*Small_stmtContext))

	return p
}

func (s *Expr_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_stmtContext) Testlist_star_expr() ITestlist_star_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestlist_star_exprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestlist_star_exprContext)
}

func (s *Expr_stmtContext) Assign_part() IAssign_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssign_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssign_partContext)
}

func (s *Expr_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterExpr_stmt(s)
	}
}

func (s *Expr_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitExpr_stmt(s)
	}
}

type Raise_stmtContext struct {
	*Small_stmtContext
}

func NewRaise_stmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Raise_stmtContext {
	var p = new(Raise_stmtContext)

	p.Small_stmtContext = NewEmptySmall_stmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*Small_stmtContext))

	return p
}

func (s *Raise_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Raise_stmtContext) RAISE() antlr.TerminalNode {
	return s.GetToken(PythonParserRAISE, 0)
}

func (s *Raise_stmtContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *Raise_stmtContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Raise_stmtContext) FROM() antlr.TerminalNode {
	return s.GetToken(PythonParserFROM, 0)
}

func (s *Raise_stmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(PythonParserCOMMA)
}

func (s *Raise_stmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(PythonParserCOMMA, i)
}

func (s *Raise_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterRaise_stmt(s)
	}
}

func (s *Raise_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitRaise_stmt(s)
	}
}

type Yield_stmtContext struct {
	*Small_stmtContext
}

func NewYield_stmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Yield_stmtContext {
	var p = new(Yield_stmtContext)

	p.Small_stmtContext = NewEmptySmall_stmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*Small_stmtContext))

	return p
}

func (s *Yield_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Yield_stmtContext) Yield_expr() IYield_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IYield_exprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IYield_exprContext)
}

func (s *Yield_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterYield_stmt(s)
	}
}

func (s *Yield_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitYield_stmt(s)
	}
}

type From_stmtContext struct {
	*Small_stmtContext
}

func NewFrom_stmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *From_stmtContext {
	var p = new(From_stmtContext)

	p.Small_stmtContext = NewEmptySmall_stmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*Small_stmtContext))

	return p
}

func (s *From_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *From_stmtContext) FROM() antlr.TerminalNode {
	return s.GetToken(PythonParserFROM, 0)
}

func (s *From_stmtContext) From_stmt_source() IFrom_stmt_sourceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFrom_stmt_sourceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFrom_stmt_sourceContext)
}

func (s *From_stmtContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(PythonParserIMPORT, 0)
}

func (s *From_stmtContext) From_stmt_as_names() IFrom_stmt_as_namesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFrom_stmt_as_namesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFrom_stmt_as_namesContext)
}

func (s *From_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterFrom_stmt(s)
	}
}

func (s *From_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitFrom_stmt(s)
	}
}

type Global_stmtContext struct {
	*Small_stmtContext
}

func NewGlobal_stmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Global_stmtContext {
	var p = new(Global_stmtContext)

	p.Small_stmtContext = NewEmptySmall_stmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*Small_stmtContext))

	return p
}

func (s *Global_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Global_stmtContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(PythonParserGLOBAL, 0)
}

func (s *Global_stmtContext) AllName() []INameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INameContext)(nil)).Elem())
	var tst = make([]INameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INameContext)
		}
	}

	return tst
}

func (s *Global_stmtContext) Name(i int) INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Global_stmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(PythonParserCOMMA)
}

func (s *Global_stmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(PythonParserCOMMA, i)
}

func (s *Global_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterGlobal_stmt(s)
	}
}

func (s *Global_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitGlobal_stmt(s)
	}
}

type Continue_stmtContext struct {
	*Small_stmtContext
}

func NewContinue_stmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Continue_stmtContext {
	var p = new(Continue_stmtContext)

	p.Small_stmtContext = NewEmptySmall_stmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*Small_stmtContext))

	return p
}

func (s *Continue_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Continue_stmtContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(PythonParserCONTINUE, 0)
}

func (s *Continue_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterContinue_stmt(s)
	}
}

func (s *Continue_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitContinue_stmt(s)
	}
}

type Exec_stmtContext struct {
	*Small_stmtContext
}

func NewExec_stmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Exec_stmtContext {
	var p = new(Exec_stmtContext)

	p.Small_stmtContext = NewEmptySmall_stmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*Small_stmtContext))

	return p
}

func (s *Exec_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Exec_stmtContext) EXEC() antlr.TerminalNode {
	return s.GetToken(PythonParserEXEC, 0)
}

func (s *Exec_stmtContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Exec_stmtContext) IN() antlr.TerminalNode {
	return s.GetToken(PythonParserIN, 0)
}

func (s *Exec_stmtContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *Exec_stmtContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Exec_stmtContext) COMMA() antlr.TerminalNode {
	return s.GetToken(PythonParserCOMMA, 0)
}

func (s *Exec_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterExec_stmt(s)
	}
}

func (s *Exec_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitExec_stmt(s)
	}
}

type Break_stmtContext struct {
	*Small_stmtContext
}

func NewBreak_stmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Break_stmtContext {
	var p = new(Break_stmtContext)

	p.Small_stmtContext = NewEmptySmall_stmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*Small_stmtContext))

	return p
}

func (s *Break_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Break_stmtContext) BREAK() antlr.TerminalNode {
	return s.GetToken(PythonParserBREAK, 0)
}

func (s *Break_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterBreak_stmt(s)
	}
}

func (s *Break_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitBreak_stmt(s)
	}
}

type Del_stmtContext struct {
	*Small_stmtContext
}

func NewDel_stmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Del_stmtContext {
	var p = new(Del_stmtContext)

	p.Small_stmtContext = NewEmptySmall_stmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*Small_stmtContext))

	return p
}

func (s *Del_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Del_stmtContext) DEL() antlr.TerminalNode {
	return s.GetToken(PythonParserDEL, 0)
}

func (s *Del_stmtContext) Exprlist() IExprlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprlistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprlistContext)
}

func (s *Del_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterDel_stmt(s)
	}
}

func (s *Del_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitDel_stmt(s)
	}
}

type Print_stmtContext struct {
	*Small_stmtContext
}

func NewPrint_stmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Print_stmtContext {
	var p = new(Print_stmtContext)

	p.Small_stmtContext = NewEmptySmall_stmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*Small_stmtContext))

	return p
}

func (s *Print_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Print_stmtContext) PRINT() antlr.TerminalNode {
	return s.GetToken(PythonParserPRINT, 0)
}

func (s *Print_stmtContext) RIGHT_SHIFT() antlr.TerminalNode {
	return s.GetToken(PythonParserRIGHT_SHIFT, 0)
}

func (s *Print_stmtContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *Print_stmtContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Print_stmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(PythonParserCOMMA)
}

func (s *Print_stmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(PythonParserCOMMA, i)
}

func (s *Print_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterPrint_stmt(s)
	}
}

func (s *Print_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitPrint_stmt(s)
	}
}

type Return_stmtContext struct {
	*Small_stmtContext
}

func NewReturn_stmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Return_stmtContext {
	var p = new(Return_stmtContext)

	p.Small_stmtContext = NewEmptySmall_stmtContext()
	p.parser = parser
	p.CopyFrom(ctx.(*Small_stmtContext))

	return p
}

func (s *Return_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Return_stmtContext) RETURN() antlr.TerminalNode {
	return s.GetToken(PythonParserRETURN, 0)
}

func (s *Return_stmtContext) Testlist() ITestlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestlistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestlistContext)
}

func (s *Return_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterReturn_stmt(s)
	}
}

func (s *Return_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitReturn_stmt(s)
	}
}

func (p *PythonParser) Small_stmt() (localctx ISmall_stmtContext) {
	localctx = NewSmall_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, PythonParserRULE_small_stmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(489)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 61, p.GetParserRuleContext()) {
	case 1:
		localctx = NewExpr_stmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(384)
			p.Testlist_star_expr()
		}
		p.SetState(386)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 45, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(385)
				p.Assign_part()
			}

		}

	case 2:
		localctx = NewPrint_stmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(388)

		if !(p.CheckVersion(2)) {
			panic(antlr.NewFailedPredicateException(p, "p.CheckVersion(2)", ""))
		}
		{
			p.SetState(389)
			p.Match(PythonParserPRINT)
		}
		p.SetState(412)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case PythonParserNONE, PythonParserLAMBDA, PythonParserNOT, PythonParserAWAIT, PythonParserPRINT, PythonParserEXEC, PythonParserTRUE, PythonParserFALSE, PythonParserELLIPSIS, PythonParserREVERSE_QUOTE, PythonParserADD, PythonParserMINUS, PythonParserNOT_OP, PythonParserSTRING, PythonParserDECIMAL_INTEGER, PythonParserOCT_INTEGER, PythonParserHEX_INTEGER, PythonParserBIN_INTEGER, PythonParserIMAG_NUMBER, PythonParserFLOAT_NUMBER, PythonParserOPEN_PAREN, PythonParserOPEN_BRACE, PythonParserOPEN_BRACKET, PythonParserNAME:
			{
				p.SetState(390)
				p.Test()
			}
			p.SetState(395)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 46, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(391)
						p.Match(PythonParserCOMMA)
					}
					{
						p.SetState(392)
						p.Test()
					}

				}
				p.SetState(397)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 46, p.GetParserRuleContext())
			}
			p.SetState(399)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == PythonParserCOMMA {
				{
					p.SetState(398)
					p.Match(PythonParserCOMMA)
				}

			}

		case PythonParserRIGHT_SHIFT:
			{
				p.SetState(401)
				p.Match(PythonParserRIGHT_SHIFT)
			}
			{
				p.SetState(402)
				p.Test()
			}

			p.SetState(405)
			p.GetErrorHandler().Sync(p)
			_alt = 1
			for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				switch _alt {
				case 1:
					{
						p.SetState(403)
						p.Match(PythonParserCOMMA)
					}
					{
						p.SetState(404)
						p.Test()
					}

				default:
					panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				}

				p.SetState(407)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 48, p.GetParserRuleContext())
			}
			p.SetState(410)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == PythonParserCOMMA {
				{
					p.SetState(409)
					p.Match(PythonParserCOMMA)
				}

			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		p.SetVersion(2)

	case 3:
		localctx = NewDel_stmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(416)
			p.Match(PythonParserDEL)
		}
		{
			p.SetState(417)
			p.Exprlist()
		}

	case 4:
		localctx = NewPass_stmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(418)
			p.Match(PythonParserPASS)
		}

	case 5:
		localctx = NewBreak_stmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(419)
			p.Match(PythonParserBREAK)
		}

	case 6:
		localctx = NewContinue_stmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(420)
			p.Match(PythonParserCONTINUE)
		}

	case 7:
		localctx = NewReturn_stmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(421)
			p.Match(PythonParserRETURN)
		}
		p.SetState(423)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PythonParserNONE)|(1<<PythonParserLAMBDA)|(1<<PythonParserNOT))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(PythonParserAWAIT-36))|(1<<(PythonParserPRINT-36))|(1<<(PythonParserEXEC-36))|(1<<(PythonParserTRUE-36))|(1<<(PythonParserFALSE-36))|(1<<(PythonParserELLIPSIS-36))|(1<<(PythonParserREVERSE_QUOTE-36))|(1<<(PythonParserADD-36))|(1<<(PythonParserMINUS-36))|(1<<(PythonParserNOT_OP-36)))) != 0) || (((_la-83)&-(0x1f+1)) == 0 && ((1<<uint((_la-83)))&((1<<(PythonParserSTRING-83))|(1<<(PythonParserDECIMAL_INTEGER-83))|(1<<(PythonParserOCT_INTEGER-83))|(1<<(PythonParserHEX_INTEGER-83))|(1<<(PythonParserBIN_INTEGER-83))|(1<<(PythonParserIMAG_NUMBER-83))|(1<<(PythonParserFLOAT_NUMBER-83))|(1<<(PythonParserOPEN_PAREN-83))|(1<<(PythonParserOPEN_BRACE-83))|(1<<(PythonParserOPEN_BRACKET-83))|(1<<(PythonParserNAME-83)))) != 0) {
			{
				p.SetState(422)
				p.Testlist()
			}

		}

	case 8:
		localctx = NewRaise_stmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(425)
			p.Match(PythonParserRAISE)
		}
		p.SetState(435)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PythonParserNONE)|(1<<PythonParserLAMBDA)|(1<<PythonParserNOT))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(PythonParserAWAIT-36))|(1<<(PythonParserPRINT-36))|(1<<(PythonParserEXEC-36))|(1<<(PythonParserTRUE-36))|(1<<(PythonParserFALSE-36))|(1<<(PythonParserELLIPSIS-36))|(1<<(PythonParserREVERSE_QUOTE-36))|(1<<(PythonParserADD-36))|(1<<(PythonParserMINUS-36))|(1<<(PythonParserNOT_OP-36)))) != 0) || (((_la-83)&-(0x1f+1)) == 0 && ((1<<uint((_la-83)))&((1<<(PythonParserSTRING-83))|(1<<(PythonParserDECIMAL_INTEGER-83))|(1<<(PythonParserOCT_INTEGER-83))|(1<<(PythonParserHEX_INTEGER-83))|(1<<(PythonParserBIN_INTEGER-83))|(1<<(PythonParserIMAG_NUMBER-83))|(1<<(PythonParserFLOAT_NUMBER-83))|(1<<(PythonParserOPEN_PAREN-83))|(1<<(PythonParserOPEN_BRACE-83))|(1<<(PythonParserOPEN_BRACKET-83))|(1<<(PythonParserNAME-83)))) != 0) {
			{
				p.SetState(426)
				p.Test()
			}
			p.SetState(433)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == PythonParserCOMMA {
				{
					p.SetState(427)
					p.Match(PythonParserCOMMA)
				}
				{
					p.SetState(428)
					p.Test()
				}
				p.SetState(431)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == PythonParserCOMMA {
					{
						p.SetState(429)
						p.Match(PythonParserCOMMA)
					}
					{
						p.SetState(430)
						p.Test()
					}

				}

			}

		}
		p.SetState(439)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PythonParserFROM {
			{
				p.SetState(437)
				p.Match(PythonParserFROM)
			}
			{
				p.SetState(438)
				p.Test()
			}

		}

	case 9:
		localctx = NewYield_stmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(441)
			p.Yield_expr()
		}

	case 10:
		localctx = NewImport_stmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(442)
			p.Match(PythonParserIMPORT)
		}
		{
			p.SetState(443)
			p.Dotted_as_names()
		}

	case 11:
		localctx = NewFrom_stmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(444)
			p.Match(PythonParserFROM)
		}
		{
			p.SetState(445)
			p.From_stmt_source()
		}
		{
			p.SetState(446)
			p.Match(PythonParserIMPORT)
		}
		{
			p.SetState(447)
			p.From_stmt_as_names()
		}

	case 12:
		localctx = NewGlobal_stmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(449)
			p.Match(PythonParserGLOBAL)
		}
		{
			p.SetState(450)
			p.Name()
		}
		p.SetState(455)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PythonParserCOMMA {
			{
				p.SetState(451)
				p.Match(PythonParserCOMMA)
			}
			{
				p.SetState(452)
				p.Name()
			}

			p.SetState(457)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 13:
		localctx = NewExec_stmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		p.SetState(458)

		if !(p.CheckVersion(2)) {
			panic(antlr.NewFailedPredicateException(p, "p.CheckVersion(2)", ""))
		}
		{
			p.SetState(459)
			p.Match(PythonParserEXEC)
		}
		{
			p.SetState(460)
			p.expr(0)
		}
		p.SetState(467)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PythonParserIN {
			{
				p.SetState(461)
				p.Match(PythonParserIN)
			}
			{
				p.SetState(462)
				p.Test()
			}
			p.SetState(465)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == PythonParserCOMMA {
				{
					p.SetState(463)
					p.Match(PythonParserCOMMA)
				}
				{
					p.SetState(464)
					p.Test()
				}

			}

		}
		p.SetVersion(2)

	case 14:
		localctx = NewAssert_stmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(471)
			p.Match(PythonParserASSERT)
		}
		{
			p.SetState(472)
			p.Test()
		}
		p.SetState(475)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PythonParserCOMMA {
			{
				p.SetState(473)
				p.Match(PythonParserCOMMA)
			}
			{
				p.SetState(474)
				p.Test()
			}

		}

	case 15:
		localctx = NewNonlocal_stmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		p.SetState(477)

		if !(p.CheckVersion(3)) {
			panic(antlr.NewFailedPredicateException(p, "p.CheckVersion(3)", ""))
		}
		{
			p.SetState(478)
			p.Match(PythonParserNONLOCAL)
		}
		{
			p.SetState(479)
			p.Name()
		}
		p.SetState(484)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PythonParserCOMMA {
			{
				p.SetState(480)
				p.Match(PythonParserCOMMA)
			}
			{
				p.SetState(481)
				p.Name()
			}

			p.SetState(486)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetVersion(3)

	}

	return localctx
}

// IFrom_stmt_sourceContext is an interface to support dynamic dispatch.
type IFrom_stmt_sourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFrom_stmt_sourceContext differentiates from other interfaces.
	IsFrom_stmt_sourceContext()
}

type From_stmt_sourceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrom_stmt_sourceContext() *From_stmt_sourceContext {
	var p = new(From_stmt_sourceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_from_stmt_source
	return p
}

func (*From_stmt_sourceContext) IsFrom_stmt_sourceContext() {}

func NewFrom_stmt_sourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *From_stmt_sourceContext {
	var p = new(From_stmt_sourceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_from_stmt_source

	return p
}

func (s *From_stmt_sourceContext) GetParser() antlr.Parser { return s.parser }

func (s *From_stmt_sourceContext) Dotted_name() IDotted_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDotted_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDotted_nameContext)
}

func (s *From_stmt_sourceContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(PythonParserDOT)
}

func (s *From_stmt_sourceContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(PythonParserDOT, i)
}

func (s *From_stmt_sourceContext) AllELLIPSIS() []antlr.TerminalNode {
	return s.GetTokens(PythonParserELLIPSIS)
}

func (s *From_stmt_sourceContext) ELLIPSIS(i int) antlr.TerminalNode {
	return s.GetToken(PythonParserELLIPSIS, i)
}

func (s *From_stmt_sourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *From_stmt_sourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *From_stmt_sourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterFrom_stmt_source(s)
	}
}

func (s *From_stmt_sourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitFrom_stmt_source(s)
	}
}

func (p *PythonParser) From_stmt_source() (localctx IFrom_stmt_sourceContext) {
	localctx = NewFrom_stmt_sourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, PythonParserRULE_from_stmt_source)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(503)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 64, p.GetParserRuleContext()) {
	case 1:
		p.SetState(494)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PythonParserDOT || _la == PythonParserELLIPSIS {
			{
				p.SetState(491)
				_la = p.GetTokenStream().LA(1)

				if !(_la == PythonParserDOT || _la == PythonParserELLIPSIS) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

			p.SetState(496)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(497)
			p.dotted_name(0)
		}

	case 2:
		p.SetState(499)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == PythonParserDOT || _la == PythonParserELLIPSIS {
			{
				p.SetState(498)
				_la = p.GetTokenStream().LA(1)

				if !(_la == PythonParserDOT || _la == PythonParserELLIPSIS) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

			p.SetState(501)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IFrom_stmt_as_namesContext is an interface to support dynamic dispatch.
type IFrom_stmt_as_namesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFrom_stmt_as_namesContext differentiates from other interfaces.
	IsFrom_stmt_as_namesContext()
}

type From_stmt_as_namesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrom_stmt_as_namesContext() *From_stmt_as_namesContext {
	var p = new(From_stmt_as_namesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_from_stmt_as_names
	return p
}

func (*From_stmt_as_namesContext) IsFrom_stmt_as_namesContext() {}

func NewFrom_stmt_as_namesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *From_stmt_as_namesContext {
	var p = new(From_stmt_as_namesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_from_stmt_as_names

	return p
}

func (s *From_stmt_as_namesContext) GetParser() antlr.Parser { return s.parser }

func (s *From_stmt_as_namesContext) STAR() antlr.TerminalNode {
	return s.GetToken(PythonParserSTAR, 0)
}

func (s *From_stmt_as_namesContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(PythonParserOPEN_PAREN, 0)
}

func (s *From_stmt_as_namesContext) Import_as_names() IImport_as_namesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImport_as_namesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImport_as_namesContext)
}

func (s *From_stmt_as_namesContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(PythonParserCLOSE_PAREN, 0)
}

func (s *From_stmt_as_namesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *From_stmt_as_namesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *From_stmt_as_namesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterFrom_stmt_as_names(s)
	}
}

func (s *From_stmt_as_namesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitFrom_stmt_as_names(s)
	}
}

func (p *PythonParser) From_stmt_as_names() (localctx IFrom_stmt_as_namesContext) {
	localctx = NewFrom_stmt_as_namesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, PythonParserRULE_from_stmt_as_names)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(511)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PythonParserSTAR:
		{
			p.SetState(505)
			p.Match(PythonParserSTAR)
		}

	case PythonParserOPEN_PAREN:
		{
			p.SetState(506)
			p.Match(PythonParserOPEN_PAREN)
		}
		{
			p.SetState(507)
			p.Import_as_names()
		}
		{
			p.SetState(508)
			p.Match(PythonParserCLOSE_PAREN)
		}

	case PythonParserTRUE, PythonParserFALSE, PythonParserNAME:
		{
			p.SetState(510)
			p.Import_as_names()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITestlist_star_exprContext is an interface to support dynamic dispatch.
type ITestlist_star_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTestlist_star_exprContext differentiates from other interfaces.
	IsTestlist_star_exprContext()
}

type Testlist_star_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTestlist_star_exprContext() *Testlist_star_exprContext {
	var p = new(Testlist_star_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_testlist_star_expr
	return p
}

func (*Testlist_star_exprContext) IsTestlist_star_exprContext() {}

func NewTestlist_star_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Testlist_star_exprContext {
	var p = new(Testlist_star_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_testlist_star_expr

	return p
}

func (s *Testlist_star_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Testlist_star_exprContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(PythonParserCOMMA)
}

func (s *Testlist_star_exprContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(PythonParserCOMMA, i)
}

func (s *Testlist_star_exprContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *Testlist_star_exprContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Testlist_star_exprContext) AllStar_expr() []IStar_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStar_exprContext)(nil)).Elem())
	var tst = make([]IStar_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStar_exprContext)
		}
	}

	return tst
}

func (s *Testlist_star_exprContext) Star_expr(i int) IStar_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStar_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStar_exprContext)
}

func (s *Testlist_star_exprContext) Testlist() ITestlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestlistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestlistContext)
}

func (s *Testlist_star_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Testlist_star_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Testlist_star_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterTestlist_star_expr(s)
	}
}

func (s *Testlist_star_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitTestlist_star_expr(s)
	}
}

func (p *PythonParser) Testlist_star_expr() (localctx ITestlist_star_exprContext) {
	localctx = NewTestlist_star_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, PythonParserRULE_testlist_star_expr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(528)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 69, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(519)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				p.SetState(515)
				p.GetErrorHandler().Sync(p)

				switch p.GetTokenStream().LA(1) {
				case PythonParserNONE, PythonParserLAMBDA, PythonParserNOT, PythonParserAWAIT, PythonParserPRINT, PythonParserEXEC, PythonParserTRUE, PythonParserFALSE, PythonParserELLIPSIS, PythonParserREVERSE_QUOTE, PythonParserADD, PythonParserMINUS, PythonParserNOT_OP, PythonParserSTRING, PythonParserDECIMAL_INTEGER, PythonParserOCT_INTEGER, PythonParserHEX_INTEGER, PythonParserBIN_INTEGER, PythonParserIMAG_NUMBER, PythonParserFLOAT_NUMBER, PythonParserOPEN_PAREN, PythonParserOPEN_BRACE, PythonParserOPEN_BRACKET, PythonParserNAME:
					{
						p.SetState(513)
						p.Test()
					}

				case PythonParserSTAR:
					{
						p.SetState(514)
						p.Star_expr()
					}

				default:
					panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				}
				{
					p.SetState(517)
					p.Match(PythonParserCOMMA)
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(521)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 67, p.GetParserRuleContext())
		}
		p.SetState(525)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 68, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(523)
				p.Test()
			}

		} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 68, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(524)
				p.Star_expr()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(527)
			p.Testlist()
		}

	}

	return localctx
}

// IStar_exprContext is an interface to support dynamic dispatch.
type IStar_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStar_exprContext differentiates from other interfaces.
	IsStar_exprContext()
}

type Star_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStar_exprContext() *Star_exprContext {
	var p = new(Star_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_star_expr
	return p
}

func (*Star_exprContext) IsStar_exprContext() {}

func NewStar_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Star_exprContext {
	var p = new(Star_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_star_expr

	return p
}

func (s *Star_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Star_exprContext) STAR() antlr.TerminalNode {
	return s.GetToken(PythonParserSTAR, 0)
}

func (s *Star_exprContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Star_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Star_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Star_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterStar_expr(s)
	}
}

func (s *Star_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitStar_expr(s)
	}
}

func (p *PythonParser) Star_expr() (localctx IStar_exprContext) {
	localctx = NewStar_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, PythonParserRULE_star_expr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(530)
		p.Match(PythonParserSTAR)
	}
	{
		p.SetState(531)
		p.expr(0)
	}

	return localctx
}

// IAssign_partContext is an interface to support dynamic dispatch.
type IAssign_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// IsAssign_partContext differentiates from other interfaces.
	IsAssign_partContext()
}

type Assign_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	op     antlr.Token
}

func NewEmptyAssign_partContext() *Assign_partContext {
	var p = new(Assign_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_assign_part
	return p
}

func (*Assign_partContext) IsAssign_partContext() {}

func NewAssign_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assign_partContext {
	var p = new(Assign_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_assign_part

	return p
}

func (s *Assign_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Assign_partContext) GetOp() antlr.Token { return s.op }

func (s *Assign_partContext) SetOp(v antlr.Token) { s.op = v }

func (s *Assign_partContext) AllASSIGN() []antlr.TerminalNode {
	return s.GetTokens(PythonParserASSIGN)
}

func (s *Assign_partContext) ASSIGN(i int) antlr.TerminalNode {
	return s.GetToken(PythonParserASSIGN, i)
}

func (s *Assign_partContext) AllTestlist_star_expr() []ITestlist_star_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestlist_star_exprContext)(nil)).Elem())
	var tst = make([]ITestlist_star_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestlist_star_exprContext)
		}
	}

	return tst
}

func (s *Assign_partContext) Testlist_star_expr(i int) ITestlist_star_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestlist_star_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestlist_star_exprContext)
}

func (s *Assign_partContext) Yield_expr() IYield_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IYield_exprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IYield_exprContext)
}

func (s *Assign_partContext) COLON() antlr.TerminalNode {
	return s.GetToken(PythonParserCOLON, 0)
}

func (s *Assign_partContext) Test() ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Assign_partContext) Testlist() ITestlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestlistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestlistContext)
}

func (s *Assign_partContext) ADD_ASSIGN() antlr.TerminalNode {
	return s.GetToken(PythonParserADD_ASSIGN, 0)
}

func (s *Assign_partContext) SUB_ASSIGN() antlr.TerminalNode {
	return s.GetToken(PythonParserSUB_ASSIGN, 0)
}

func (s *Assign_partContext) MULT_ASSIGN() antlr.TerminalNode {
	return s.GetToken(PythonParserMULT_ASSIGN, 0)
}

func (s *Assign_partContext) AT_ASSIGN() antlr.TerminalNode {
	return s.GetToken(PythonParserAT_ASSIGN, 0)
}

func (s *Assign_partContext) DIV_ASSIGN() antlr.TerminalNode {
	return s.GetToken(PythonParserDIV_ASSIGN, 0)
}

func (s *Assign_partContext) MOD_ASSIGN() antlr.TerminalNode {
	return s.GetToken(PythonParserMOD_ASSIGN, 0)
}

func (s *Assign_partContext) AND_ASSIGN() antlr.TerminalNode {
	return s.GetToken(PythonParserAND_ASSIGN, 0)
}

func (s *Assign_partContext) OR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(PythonParserOR_ASSIGN, 0)
}

func (s *Assign_partContext) XOR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(PythonParserXOR_ASSIGN, 0)
}

func (s *Assign_partContext) LEFT_SHIFT_ASSIGN() antlr.TerminalNode {
	return s.GetToken(PythonParserLEFT_SHIFT_ASSIGN, 0)
}

func (s *Assign_partContext) RIGHT_SHIFT_ASSIGN() antlr.TerminalNode {
	return s.GetToken(PythonParserRIGHT_SHIFT_ASSIGN, 0)
}

func (s *Assign_partContext) POWER_ASSIGN() antlr.TerminalNode {
	return s.GetToken(PythonParserPOWER_ASSIGN, 0)
}

func (s *Assign_partContext) IDIV_ASSIGN() antlr.TerminalNode {
	return s.GetToken(PythonParserIDIV_ASSIGN, 0)
}

func (s *Assign_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assign_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Assign_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterAssign_part(s)
	}
}

func (s *Assign_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitAssign_part(s)
	}
}

func (p *PythonParser) Assign_part() (localctx IAssign_partContext) {
	localctx = NewAssign_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, PythonParserRULE_assign_part)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(563)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(533)
			p.Match(PythonParserASSIGN)
		}
		p.SetState(547)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case PythonParserNONE, PythonParserLAMBDA, PythonParserNOT, PythonParserAWAIT, PythonParserPRINT, PythonParserEXEC, PythonParserTRUE, PythonParserFALSE, PythonParserELLIPSIS, PythonParserREVERSE_QUOTE, PythonParserSTAR, PythonParserADD, PythonParserMINUS, PythonParserNOT_OP, PythonParserSTRING, PythonParserDECIMAL_INTEGER, PythonParserOCT_INTEGER, PythonParserHEX_INTEGER, PythonParserBIN_INTEGER, PythonParserIMAG_NUMBER, PythonParserFLOAT_NUMBER, PythonParserOPEN_PAREN, PythonParserOPEN_BRACE, PythonParserOPEN_BRACKET, PythonParserNAME:
			{
				p.SetState(534)
				p.Testlist_star_expr()
			}
			p.SetState(539)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 70, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(535)
						p.Match(PythonParserASSIGN)
					}
					{
						p.SetState(536)
						p.Testlist_star_expr()
					}

				}
				p.SetState(541)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 70, p.GetParserRuleContext())
			}
			p.SetState(544)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == PythonParserASSIGN {
				{
					p.SetState(542)
					p.Match(PythonParserASSIGN)
				}
				{
					p.SetState(543)
					p.Yield_expr()
				}

			}

		case PythonParserYIELD:
			{
				p.SetState(546)
				p.Yield_expr()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(549)

		if !(p.CheckVersion(3)) {
			panic(antlr.NewFailedPredicateException(p, "p.CheckVersion(3)", ""))
		}
		{
			p.SetState(550)
			p.Match(PythonParserCOLON)
		}
		{
			p.SetState(551)
			p.Test()
		}
		p.SetState(554)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PythonParserASSIGN {
			{
				p.SetState(552)
				p.Match(PythonParserASSIGN)
			}
			{
				p.SetState(553)
				p.Testlist()
			}

		}
		p.SetVersion(3)

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(558)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*Assign_partContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(PythonParserADD_ASSIGN-70))|(1<<(PythonParserSUB_ASSIGN-70))|(1<<(PythonParserMULT_ASSIGN-70))|(1<<(PythonParserAT_ASSIGN-70))|(1<<(PythonParserDIV_ASSIGN-70))|(1<<(PythonParserMOD_ASSIGN-70))|(1<<(PythonParserAND_ASSIGN-70))|(1<<(PythonParserOR_ASSIGN-70))|(1<<(PythonParserXOR_ASSIGN-70))|(1<<(PythonParserLEFT_SHIFT_ASSIGN-70))|(1<<(PythonParserRIGHT_SHIFT_ASSIGN-70))|(1<<(PythonParserPOWER_ASSIGN-70))|(1<<(PythonParserIDIV_ASSIGN-70)))) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*Assign_partContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(561)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case PythonParserYIELD:
			{
				p.SetState(559)
				p.Yield_expr()
			}

		case PythonParserNONE, PythonParserLAMBDA, PythonParserNOT, PythonParserAWAIT, PythonParserPRINT, PythonParserEXEC, PythonParserTRUE, PythonParserFALSE, PythonParserELLIPSIS, PythonParserREVERSE_QUOTE, PythonParserADD, PythonParserMINUS, PythonParserNOT_OP, PythonParserSTRING, PythonParserDECIMAL_INTEGER, PythonParserOCT_INTEGER, PythonParserHEX_INTEGER, PythonParserBIN_INTEGER, PythonParserIMAG_NUMBER, PythonParserFLOAT_NUMBER, PythonParserOPEN_PAREN, PythonParserOPEN_BRACE, PythonParserOPEN_BRACKET, PythonParserNAME:
			{
				p.SetState(560)
				p.Testlist()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	}

	return localctx
}

// IExprlistContext is an interface to support dynamic dispatch.
type IExprlistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExprlistContext differentiates from other interfaces.
	IsExprlistContext()
}

type ExprlistContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprlistContext() *ExprlistContext {
	var p = new(ExprlistContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_exprlist
	return p
}

func (*ExprlistContext) IsExprlistContext() {}

func NewExprlistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprlistContext {
	var p = new(ExprlistContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_exprlist

	return p
}

func (s *ExprlistContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprlistContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ExprlistContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprlistContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(PythonParserCOMMA)
}

func (s *ExprlistContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(PythonParserCOMMA, i)
}

func (s *ExprlistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprlistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprlistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterExprlist(s)
	}
}

func (s *ExprlistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitExprlist(s)
	}
}

func (p *PythonParser) Exprlist() (localctx IExprlistContext) {
	localctx = NewExprlistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, PythonParserRULE_exprlist)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(565)
		p.expr(0)
	}
	p.SetState(570)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 76, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(566)
				p.Match(PythonParserCOMMA)
			}
			{
				p.SetState(567)
				p.expr(0)
			}

		}
		p.SetState(572)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 76, p.GetParserRuleContext())
	}
	p.SetState(574)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PythonParserCOMMA {
		{
			p.SetState(573)
			p.Match(PythonParserCOMMA)
		}

	}

	return localctx
}

// IImport_as_namesContext is an interface to support dynamic dispatch.
type IImport_as_namesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImport_as_namesContext differentiates from other interfaces.
	IsImport_as_namesContext()
}

type Import_as_namesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImport_as_namesContext() *Import_as_namesContext {
	var p = new(Import_as_namesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_import_as_names
	return p
}

func (*Import_as_namesContext) IsImport_as_namesContext() {}

func NewImport_as_namesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Import_as_namesContext {
	var p = new(Import_as_namesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_import_as_names

	return p
}

func (s *Import_as_namesContext) GetParser() antlr.Parser { return s.parser }

func (s *Import_as_namesContext) AllImport_as_name() []IImport_as_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IImport_as_nameContext)(nil)).Elem())
	var tst = make([]IImport_as_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IImport_as_nameContext)
		}
	}

	return tst
}

func (s *Import_as_namesContext) Import_as_name(i int) IImport_as_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImport_as_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IImport_as_nameContext)
}

func (s *Import_as_namesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(PythonParserCOMMA)
}

func (s *Import_as_namesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(PythonParserCOMMA, i)
}

func (s *Import_as_namesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Import_as_namesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Import_as_namesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterImport_as_names(s)
	}
}

func (s *Import_as_namesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitImport_as_names(s)
	}
}

func (p *PythonParser) Import_as_names() (localctx IImport_as_namesContext) {
	localctx = NewImport_as_namesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, PythonParserRULE_import_as_names)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(576)
		p.Import_as_name()
	}
	p.SetState(581)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 78, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(577)
				p.Match(PythonParserCOMMA)
			}
			{
				p.SetState(578)
				p.Import_as_name()
			}

		}
		p.SetState(583)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 78, p.GetParserRuleContext())
	}
	p.SetState(585)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PythonParserCOMMA {
		{
			p.SetState(584)
			p.Match(PythonParserCOMMA)
		}

	}

	return localctx
}

// IImport_as_nameContext is an interface to support dynamic dispatch.
type IImport_as_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImport_as_nameContext differentiates from other interfaces.
	IsImport_as_nameContext()
}

type Import_as_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImport_as_nameContext() *Import_as_nameContext {
	var p = new(Import_as_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_import_as_name
	return p
}

func (*Import_as_nameContext) IsImport_as_nameContext() {}

func NewImport_as_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Import_as_nameContext {
	var p = new(Import_as_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_import_as_name

	return p
}

func (s *Import_as_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Import_as_nameContext) AllName() []INameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INameContext)(nil)).Elem())
	var tst = make([]INameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INameContext)
		}
	}

	return tst
}

func (s *Import_as_nameContext) Name(i int) INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Import_as_nameContext) AS() antlr.TerminalNode {
	return s.GetToken(PythonParserAS, 0)
}

func (s *Import_as_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Import_as_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Import_as_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterImport_as_name(s)
	}
}

func (s *Import_as_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitImport_as_name(s)
	}
}

func (p *PythonParser) Import_as_name() (localctx IImport_as_nameContext) {
	localctx = NewImport_as_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, PythonParserRULE_import_as_name)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(587)
		p.Name()
	}
	p.SetState(590)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PythonParserAS {
		{
			p.SetState(588)
			p.Match(PythonParserAS)
		}
		{
			p.SetState(589)
			p.Name()
		}

	}

	return localctx
}

// IDotted_as_namesContext is an interface to support dynamic dispatch.
type IDotted_as_namesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDotted_as_namesContext differentiates from other interfaces.
	IsDotted_as_namesContext()
}

type Dotted_as_namesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDotted_as_namesContext() *Dotted_as_namesContext {
	var p = new(Dotted_as_namesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_dotted_as_names
	return p
}

func (*Dotted_as_namesContext) IsDotted_as_namesContext() {}

func NewDotted_as_namesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dotted_as_namesContext {
	var p = new(Dotted_as_namesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_dotted_as_names

	return p
}

func (s *Dotted_as_namesContext) GetParser() antlr.Parser { return s.parser }

func (s *Dotted_as_namesContext) AllDotted_as_name() []IDotted_as_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDotted_as_nameContext)(nil)).Elem())
	var tst = make([]IDotted_as_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDotted_as_nameContext)
		}
	}

	return tst
}

func (s *Dotted_as_namesContext) Dotted_as_name(i int) IDotted_as_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDotted_as_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDotted_as_nameContext)
}

func (s *Dotted_as_namesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(PythonParserCOMMA)
}

func (s *Dotted_as_namesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(PythonParserCOMMA, i)
}

func (s *Dotted_as_namesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dotted_as_namesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dotted_as_namesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterDotted_as_names(s)
	}
}

func (s *Dotted_as_namesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitDotted_as_names(s)
	}
}

func (p *PythonParser) Dotted_as_names() (localctx IDotted_as_namesContext) {
	localctx = NewDotted_as_namesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, PythonParserRULE_dotted_as_names)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(592)
		p.Dotted_as_name()
	}
	p.SetState(597)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PythonParserCOMMA {
		{
			p.SetState(593)
			p.Match(PythonParserCOMMA)
		}
		{
			p.SetState(594)
			p.Dotted_as_name()
		}

		p.SetState(599)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IDotted_as_nameContext is an interface to support dynamic dispatch.
type IDotted_as_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDotted_as_nameContext differentiates from other interfaces.
	IsDotted_as_nameContext()
}

type Dotted_as_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDotted_as_nameContext() *Dotted_as_nameContext {
	var p = new(Dotted_as_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_dotted_as_name
	return p
}

func (*Dotted_as_nameContext) IsDotted_as_nameContext() {}

func NewDotted_as_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dotted_as_nameContext {
	var p = new(Dotted_as_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_dotted_as_name

	return p
}

func (s *Dotted_as_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Dotted_as_nameContext) Dotted_name() IDotted_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDotted_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDotted_nameContext)
}

func (s *Dotted_as_nameContext) AS() antlr.TerminalNode {
	return s.GetToken(PythonParserAS, 0)
}

func (s *Dotted_as_nameContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Dotted_as_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dotted_as_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dotted_as_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterDotted_as_name(s)
	}
}

func (s *Dotted_as_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitDotted_as_name(s)
	}
}

func (p *PythonParser) Dotted_as_name() (localctx IDotted_as_nameContext) {
	localctx = NewDotted_as_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, PythonParserRULE_dotted_as_name)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(600)
		p.dotted_name(0)
	}
	p.SetState(603)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PythonParserAS {
		{
			p.SetState(601)
			p.Match(PythonParserAS)
		}
		{
			p.SetState(602)
			p.Name()
		}

	}

	return localctx
}

// ITestContext is an interface to support dynamic dispatch.
type ITestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTestContext differentiates from other interfaces.
	IsTestContext()
}

type TestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTestContext() *TestContext {
	var p = new(TestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_test
	return p
}

func (*TestContext) IsTestContext() {}

func NewTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TestContext {
	var p = new(TestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_test

	return p
}

func (s *TestContext) GetParser() antlr.Parser { return s.parser }

func (s *TestContext) AllLogical_test() []ILogical_testContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILogical_testContext)(nil)).Elem())
	var tst = make([]ILogical_testContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILogical_testContext)
		}
	}

	return tst
}

func (s *TestContext) Logical_test(i int) ILogical_testContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILogical_testContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILogical_testContext)
}

func (s *TestContext) IF() antlr.TerminalNode {
	return s.GetToken(PythonParserIF, 0)
}

func (s *TestContext) ELSE() antlr.TerminalNode {
	return s.GetToken(PythonParserELSE, 0)
}

func (s *TestContext) Test() ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *TestContext) LAMBDA() antlr.TerminalNode {
	return s.GetToken(PythonParserLAMBDA, 0)
}

func (s *TestContext) COLON() antlr.TerminalNode {
	return s.GetToken(PythonParserCOLON, 0)
}

func (s *TestContext) Varargslist() IVarargslistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVarargslistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVarargslistContext)
}

func (s *TestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterTest(s)
	}
}

func (s *TestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitTest(s)
	}
}

func (p *PythonParser) Test() (localctx ITestContext) {
	localctx = NewTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, PythonParserRULE_test)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(619)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PythonParserNONE, PythonParserNOT, PythonParserAWAIT, PythonParserPRINT, PythonParserEXEC, PythonParserTRUE, PythonParserFALSE, PythonParserELLIPSIS, PythonParserREVERSE_QUOTE, PythonParserADD, PythonParserMINUS, PythonParserNOT_OP, PythonParserSTRING, PythonParserDECIMAL_INTEGER, PythonParserOCT_INTEGER, PythonParserHEX_INTEGER, PythonParserBIN_INTEGER, PythonParserIMAG_NUMBER, PythonParserFLOAT_NUMBER, PythonParserOPEN_PAREN, PythonParserOPEN_BRACE, PythonParserOPEN_BRACKET, PythonParserNAME:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(605)
			p.logical_test(0)
		}
		p.SetState(611)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 83, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(606)
				p.Match(PythonParserIF)
			}
			{
				p.SetState(607)
				p.logical_test(0)
			}
			{
				p.SetState(608)
				p.Match(PythonParserELSE)
			}
			{
				p.SetState(609)
				p.Test()
			}

		}

	case PythonParserLAMBDA:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(613)
			p.Match(PythonParserLAMBDA)
		}
		p.SetState(615)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-39)&-(0x1f+1)) == 0 && ((1<<uint((_la-39)))&((1<<(PythonParserTRUE-39))|(1<<(PythonParserFALSE-39))|(1<<(PythonParserSTAR-39))|(1<<(PythonParserPOWER-39)))) != 0) || _la == PythonParserNAME {
			{
				p.SetState(614)
				p.Varargslist()
			}

		}
		{
			p.SetState(617)
			p.Match(PythonParserCOLON)
		}
		{
			p.SetState(618)
			p.Test()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IVarargslistContext is an interface to support dynamic dispatch.
type IVarargslistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVarargslistContext differentiates from other interfaces.
	IsVarargslistContext()
}

type VarargslistContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarargslistContext() *VarargslistContext {
	var p = new(VarargslistContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_varargslist
	return p
}

func (*VarargslistContext) IsVarargslistContext() {}

func NewVarargslistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarargslistContext {
	var p = new(VarargslistContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_varargslist

	return p
}

func (s *VarargslistContext) GetParser() antlr.Parser { return s.parser }

func (s *VarargslistContext) Varargs() IVarargsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVarargsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVarargsContext)
}

func (s *VarargslistContext) Varkwargs() IVarkwargsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVarkwargsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVarkwargsContext)
}

func (s *VarargslistContext) AllVardef_parameters() []IVardef_parametersContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVardef_parametersContext)(nil)).Elem())
	var tst = make([]IVardef_parametersContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVardef_parametersContext)
		}
	}

	return tst
}

func (s *VarargslistContext) Vardef_parameters(i int) IVardef_parametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVardef_parametersContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVardef_parametersContext)
}

func (s *VarargslistContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(PythonParserCOMMA)
}

func (s *VarargslistContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(PythonParserCOMMA, i)
}

func (s *VarargslistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarargslistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VarargslistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterVarargslist(s)
	}
}

func (s *VarargslistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitVarargslist(s)
	}
}

func (p *PythonParser) Varargslist() (localctx IVarargslistContext) {
	localctx = NewVarargslistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, PythonParserRULE_varargslist)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(645)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 92, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(624)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 86, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(621)
				p.Vardef_parameters()
			}
			{
				p.SetState(622)
				p.Match(PythonParserCOMMA)
			}

		}
		p.SetState(636)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case PythonParserSTAR:
			{
				p.SetState(626)
				p.Varargs()
			}
			p.SetState(629)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 87, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(627)
					p.Match(PythonParserCOMMA)
				}
				{
					p.SetState(628)
					p.Vardef_parameters()
				}

			}
			p.SetState(633)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 88, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(631)
					p.Match(PythonParserCOMMA)
				}
				{
					p.SetState(632)
					p.Varkwargs()
				}

			}

		case PythonParserPOWER:
			{
				p.SetState(635)
				p.Varkwargs()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		p.SetState(639)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PythonParserCOMMA {
			{
				p.SetState(638)
				p.Match(PythonParserCOMMA)
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(641)
			p.Vardef_parameters()
		}
		p.SetState(643)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PythonParserCOMMA {
			{
				p.SetState(642)
				p.Match(PythonParserCOMMA)
			}

		}

	}

	return localctx
}

// IVardef_parametersContext is an interface to support dynamic dispatch.
type IVardef_parametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVardef_parametersContext differentiates from other interfaces.
	IsVardef_parametersContext()
}

type Vardef_parametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVardef_parametersContext() *Vardef_parametersContext {
	var p = new(Vardef_parametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_vardef_parameters
	return p
}

func (*Vardef_parametersContext) IsVardef_parametersContext() {}

func NewVardef_parametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Vardef_parametersContext {
	var p = new(Vardef_parametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_vardef_parameters

	return p
}

func (s *Vardef_parametersContext) GetParser() antlr.Parser { return s.parser }

func (s *Vardef_parametersContext) AllVardef_parameter() []IVardef_parameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVardef_parameterContext)(nil)).Elem())
	var tst = make([]IVardef_parameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVardef_parameterContext)
		}
	}

	return tst
}

func (s *Vardef_parametersContext) Vardef_parameter(i int) IVardef_parameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVardef_parameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVardef_parameterContext)
}

func (s *Vardef_parametersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(PythonParserCOMMA)
}

func (s *Vardef_parametersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(PythonParserCOMMA, i)
}

func (s *Vardef_parametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Vardef_parametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Vardef_parametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterVardef_parameters(s)
	}
}

func (s *Vardef_parametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitVardef_parameters(s)
	}
}

func (p *PythonParser) Vardef_parameters() (localctx IVardef_parametersContext) {
	localctx = NewVardef_parametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, PythonParserRULE_vardef_parameters)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(647)
		p.Vardef_parameter()
	}
	p.SetState(652)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 93, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(648)
				p.Match(PythonParserCOMMA)
			}
			{
				p.SetState(649)
				p.Vardef_parameter()
			}

		}
		p.SetState(654)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 93, p.GetParserRuleContext())
	}

	return localctx
}

// IVardef_parameterContext is an interface to support dynamic dispatch.
type IVardef_parameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVardef_parameterContext differentiates from other interfaces.
	IsVardef_parameterContext()
}

type Vardef_parameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVardef_parameterContext() *Vardef_parameterContext {
	var p = new(Vardef_parameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_vardef_parameter
	return p
}

func (*Vardef_parameterContext) IsVardef_parameterContext() {}

func NewVardef_parameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Vardef_parameterContext {
	var p = new(Vardef_parameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_vardef_parameter

	return p
}

func (s *Vardef_parameterContext) GetParser() antlr.Parser { return s.parser }

func (s *Vardef_parameterContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Vardef_parameterContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(PythonParserASSIGN, 0)
}

func (s *Vardef_parameterContext) Test() ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Vardef_parameterContext) STAR() antlr.TerminalNode {
	return s.GetToken(PythonParserSTAR, 0)
}

func (s *Vardef_parameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Vardef_parameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Vardef_parameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterVardef_parameter(s)
	}
}

func (s *Vardef_parameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitVardef_parameter(s)
	}
}

func (p *PythonParser) Vardef_parameter() (localctx IVardef_parameterContext) {
	localctx = NewVardef_parameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, PythonParserRULE_vardef_parameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(661)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PythonParserTRUE, PythonParserFALSE, PythonParserNAME:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(655)
			p.Name()
		}
		p.SetState(658)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PythonParserASSIGN {
			{
				p.SetState(656)
				p.Match(PythonParserASSIGN)
			}
			{
				p.SetState(657)
				p.Test()
			}

		}

	case PythonParserSTAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(660)
			p.Match(PythonParserSTAR)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IVarargsContext is an interface to support dynamic dispatch.
type IVarargsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVarargsContext differentiates from other interfaces.
	IsVarargsContext()
}

type VarargsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarargsContext() *VarargsContext {
	var p = new(VarargsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_varargs
	return p
}

func (*VarargsContext) IsVarargsContext() {}

func NewVarargsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarargsContext {
	var p = new(VarargsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_varargs

	return p
}

func (s *VarargsContext) GetParser() antlr.Parser { return s.parser }

func (s *VarargsContext) STAR() antlr.TerminalNode {
	return s.GetToken(PythonParserSTAR, 0)
}

func (s *VarargsContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *VarargsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarargsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VarargsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterVarargs(s)
	}
}

func (s *VarargsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitVarargs(s)
	}
}

func (p *PythonParser) Varargs() (localctx IVarargsContext) {
	localctx = NewVarargsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, PythonParserRULE_varargs)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(663)
		p.Match(PythonParserSTAR)
	}
	{
		p.SetState(664)
		p.Name()
	}

	return localctx
}

// IVarkwargsContext is an interface to support dynamic dispatch.
type IVarkwargsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVarkwargsContext differentiates from other interfaces.
	IsVarkwargsContext()
}

type VarkwargsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarkwargsContext() *VarkwargsContext {
	var p = new(VarkwargsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_varkwargs
	return p
}

func (*VarkwargsContext) IsVarkwargsContext() {}

func NewVarkwargsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarkwargsContext {
	var p = new(VarkwargsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_varkwargs

	return p
}

func (s *VarkwargsContext) GetParser() antlr.Parser { return s.parser }

func (s *VarkwargsContext) POWER() antlr.TerminalNode {
	return s.GetToken(PythonParserPOWER, 0)
}

func (s *VarkwargsContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *VarkwargsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarkwargsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VarkwargsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterVarkwargs(s)
	}
}

func (s *VarkwargsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitVarkwargs(s)
	}
}

func (p *PythonParser) Varkwargs() (localctx IVarkwargsContext) {
	localctx = NewVarkwargsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, PythonParserRULE_varkwargs)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(666)
		p.Match(PythonParserPOWER)
	}
	{
		p.SetState(667)
		p.Name()
	}

	return localctx
}

// ILogical_testContext is an interface to support dynamic dispatch.
type ILogical_testContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// IsLogical_testContext differentiates from other interfaces.
	IsLogical_testContext()
}

type Logical_testContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	op     antlr.Token
}

func NewEmptyLogical_testContext() *Logical_testContext {
	var p = new(Logical_testContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_logical_test
	return p
}

func (*Logical_testContext) IsLogical_testContext() {}

func NewLogical_testContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Logical_testContext {
	var p = new(Logical_testContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_logical_test

	return p
}

func (s *Logical_testContext) GetParser() antlr.Parser { return s.parser }

func (s *Logical_testContext) GetOp() antlr.Token { return s.op }

func (s *Logical_testContext) SetOp(v antlr.Token) { s.op = v }

func (s *Logical_testContext) Comparison() IComparisonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComparisonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComparisonContext)
}

func (s *Logical_testContext) NOT() antlr.TerminalNode {
	return s.GetToken(PythonParserNOT, 0)
}

func (s *Logical_testContext) AllLogical_test() []ILogical_testContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILogical_testContext)(nil)).Elem())
	var tst = make([]ILogical_testContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILogical_testContext)
		}
	}

	return tst
}

func (s *Logical_testContext) Logical_test(i int) ILogical_testContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILogical_testContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILogical_testContext)
}

func (s *Logical_testContext) AND() antlr.TerminalNode {
	return s.GetToken(PythonParserAND, 0)
}

func (s *Logical_testContext) OR() antlr.TerminalNode {
	return s.GetToken(PythonParserOR, 0)
}

func (s *Logical_testContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Logical_testContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Logical_testContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterLogical_test(s)
	}
}

func (s *Logical_testContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitLogical_test(s)
	}
}

func (p *PythonParser) Logical_test() (localctx ILogical_testContext) {
	return p.logical_test(0)
}

func (p *PythonParser) logical_test(_p int) (localctx ILogical_testContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewLogical_testContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ILogical_testContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 78
	p.EnterRecursionRule(localctx, 78, PythonParserRULE_logical_test, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(673)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PythonParserNONE, PythonParserAWAIT, PythonParserPRINT, PythonParserEXEC, PythonParserTRUE, PythonParserFALSE, PythonParserELLIPSIS, PythonParserREVERSE_QUOTE, PythonParserADD, PythonParserMINUS, PythonParserNOT_OP, PythonParserSTRING, PythonParserDECIMAL_INTEGER, PythonParserOCT_INTEGER, PythonParserHEX_INTEGER, PythonParserBIN_INTEGER, PythonParserIMAG_NUMBER, PythonParserFLOAT_NUMBER, PythonParserOPEN_PAREN, PythonParserOPEN_BRACE, PythonParserOPEN_BRACKET, PythonParserNAME:
		{
			p.SetState(670)
			p.comparison(0)
		}

	case PythonParserNOT:
		{
			p.SetState(671)
			p.Match(PythonParserNOT)
		}
		{
			p.SetState(672)
			p.logical_test(3)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(683)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 98, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(681)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 97, p.GetParserRuleContext()) {
			case 1:
				localctx = NewLogical_testContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, PythonParserRULE_logical_test)
				p.SetState(675)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(676)

					var _m = p.Match(PythonParserAND)

					localctx.(*Logical_testContext).op = _m
				}
				{
					p.SetState(677)
					p.logical_test(3)
				}

			case 2:
				localctx = NewLogical_testContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, PythonParserRULE_logical_test)
				p.SetState(678)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(679)

					var _m = p.Match(PythonParserOR)

					localctx.(*Logical_testContext).op = _m
				}
				{
					p.SetState(680)
					p.logical_test(2)
				}

			}

		}
		p.SetState(685)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 98, p.GetParserRuleContext())
	}

	return localctx
}

// IComparisonContext is an interface to support dynamic dispatch.
type IComparisonContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOptional returns the optional token.
	GetOptional() antlr.Token

	// SetOptional sets the optional token.
	SetOptional(antlr.Token)

	// IsComparisonContext differentiates from other interfaces.
	IsComparisonContext()
}

type ComparisonContext struct {
	*antlr.BaseParserRuleContext
	parser   antlr.Parser
	optional antlr.Token
}

func NewEmptyComparisonContext() *ComparisonContext {
	var p = new(ComparisonContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_comparison
	return p
}

func (*ComparisonContext) IsComparisonContext() {}

func NewComparisonContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonContext {
	var p = new(ComparisonContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_comparison

	return p
}

func (s *ComparisonContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonContext) GetOptional() antlr.Token { return s.optional }

func (s *ComparisonContext) SetOptional(v antlr.Token) { s.optional = v }

func (s *ComparisonContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ComparisonContext) AllComparison() []IComparisonContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IComparisonContext)(nil)).Elem())
	var tst = make([]IComparisonContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IComparisonContext)
		}
	}

	return tst
}

func (s *ComparisonContext) Comparison(i int) IComparisonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComparisonContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IComparisonContext)
}

func (s *ComparisonContext) LESS_THAN() antlr.TerminalNode {
	return s.GetToken(PythonParserLESS_THAN, 0)
}

func (s *ComparisonContext) GREATER_THAN() antlr.TerminalNode {
	return s.GetToken(PythonParserGREATER_THAN, 0)
}

func (s *ComparisonContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(PythonParserEQUALS, 0)
}

func (s *ComparisonContext) GT_EQ() antlr.TerminalNode {
	return s.GetToken(PythonParserGT_EQ, 0)
}

func (s *ComparisonContext) LT_EQ() antlr.TerminalNode {
	return s.GetToken(PythonParserLT_EQ, 0)
}

func (s *ComparisonContext) NOT_EQ_1() antlr.TerminalNode {
	return s.GetToken(PythonParserNOT_EQ_1, 0)
}

func (s *ComparisonContext) NOT_EQ_2() antlr.TerminalNode {
	return s.GetToken(PythonParserNOT_EQ_2, 0)
}

func (s *ComparisonContext) IN() antlr.TerminalNode {
	return s.GetToken(PythonParserIN, 0)
}

func (s *ComparisonContext) IS() antlr.TerminalNode {
	return s.GetToken(PythonParserIS, 0)
}

func (s *ComparisonContext) NOT() antlr.TerminalNode {
	return s.GetToken(PythonParserNOT, 0)
}

func (s *ComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterComparison(s)
	}
}

func (s *ComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitComparison(s)
	}
}

func (p *PythonParser) Comparison() (localctx IComparisonContext) {
	return p.comparison(0)
}

func (p *PythonParser) comparison(_p int) (localctx IComparisonContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewComparisonContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IComparisonContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 80
	p.EnterRecursionRule(localctx, 80, PythonParserRULE_comparison, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(687)
		p.expr(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(710)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 102, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewComparisonContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, PythonParserRULE_comparison)
			p.SetState(689)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			p.SetState(705)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case PythonParserLESS_THAN:
				{
					p.SetState(690)
					p.Match(PythonParserLESS_THAN)
				}

			case PythonParserGREATER_THAN:
				{
					p.SetState(691)
					p.Match(PythonParserGREATER_THAN)
				}

			case PythonParserEQUALS:
				{
					p.SetState(692)
					p.Match(PythonParserEQUALS)
				}

			case PythonParserGT_EQ:
				{
					p.SetState(693)
					p.Match(PythonParserGT_EQ)
				}

			case PythonParserLT_EQ:
				{
					p.SetState(694)
					p.Match(PythonParserLT_EQ)
				}

			case PythonParserNOT_EQ_1:
				{
					p.SetState(695)
					p.Match(PythonParserNOT_EQ_1)
				}

			case PythonParserNOT_EQ_2:
				{
					p.SetState(696)
					p.Match(PythonParserNOT_EQ_2)
				}

			case PythonParserIN, PythonParserNOT:
				p.SetState(698)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == PythonParserNOT {
					{
						p.SetState(697)

						var _m = p.Match(PythonParserNOT)

						localctx.(*ComparisonContext).optional = _m
					}

				}
				{
					p.SetState(700)
					p.Match(PythonParserIN)
				}

			case PythonParserIS:
				{
					p.SetState(701)
					p.Match(PythonParserIS)
				}
				p.SetState(703)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == PythonParserNOT {
					{
						p.SetState(702)

						var _m = p.Match(PythonParserNOT)

						localctx.(*ComparisonContext).optional = _m
					}

				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}
			{
				p.SetState(707)
				p.comparison(3)
			}

		}
		p.SetState(712)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 102, p.GetParserRuleContext())
	}

	return localctx
}

// IExprContext is an interface to support dynamic dispatch.
type IExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// IsExprContext differentiates from other interfaces.
	IsExprContext()
}

type ExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	op     antlr.Token
}

func NewEmptyExprContext() *ExprContext {
	var p = new(ExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_expr
	return p
}

func (*ExprContext) IsExprContext() {}

func NewExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprContext {
	var p = new(ExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_expr

	return p
}

func (s *ExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprContext) GetOp() antlr.Token { return s.op }

func (s *ExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *ExprContext) Atom() IAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomContext)
}

func (s *ExprContext) AWAIT() antlr.TerminalNode {
	return s.GetToken(PythonParserAWAIT, 0)
}

func (s *ExprContext) AllTrailer() []ITrailerContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITrailerContext)(nil)).Elem())
	var tst = make([]ITrailerContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITrailerContext)
		}
	}

	return tst
}

func (s *ExprContext) Trailer(i int) ITrailerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITrailerContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITrailerContext)
}

func (s *ExprContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ExprContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprContext) ADD() antlr.TerminalNode {
	return s.GetToken(PythonParserADD, 0)
}

func (s *ExprContext) MINUS() antlr.TerminalNode {
	return s.GetToken(PythonParserMINUS, 0)
}

func (s *ExprContext) NOT_OP() antlr.TerminalNode {
	return s.GetToken(PythonParserNOT_OP, 0)
}

func (s *ExprContext) POWER() antlr.TerminalNode {
	return s.GetToken(PythonParserPOWER, 0)
}

func (s *ExprContext) STAR() antlr.TerminalNode {
	return s.GetToken(PythonParserSTAR, 0)
}

func (s *ExprContext) DIV() antlr.TerminalNode {
	return s.GetToken(PythonParserDIV, 0)
}

func (s *ExprContext) MOD() antlr.TerminalNode {
	return s.GetToken(PythonParserMOD, 0)
}

func (s *ExprContext) IDIV() antlr.TerminalNode {
	return s.GetToken(PythonParserIDIV, 0)
}

func (s *ExprContext) AT() antlr.TerminalNode {
	return s.GetToken(PythonParserAT, 0)
}

func (s *ExprContext) LEFT_SHIFT() antlr.TerminalNode {
	return s.GetToken(PythonParserLEFT_SHIFT, 0)
}

func (s *ExprContext) RIGHT_SHIFT() antlr.TerminalNode {
	return s.GetToken(PythonParserRIGHT_SHIFT, 0)
}

func (s *ExprContext) AND_OP() antlr.TerminalNode {
	return s.GetToken(PythonParserAND_OP, 0)
}

func (s *ExprContext) XOR() antlr.TerminalNode {
	return s.GetToken(PythonParserXOR, 0)
}

func (s *ExprContext) OR_OP() antlr.TerminalNode {
	return s.GetToken(PythonParserOR_OP, 0)
}

func (s *ExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterExpr(s)
	}
}

func (s *ExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitExpr(s)
	}
}

func (p *PythonParser) Expr() (localctx IExprContext) {
	return p.expr(0)
}

func (p *PythonParser) expr(_p int) (localctx IExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 82
	p.EnterRecursionRule(localctx, 82, PythonParserRULE_expr, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(726)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 105, p.GetParserRuleContext()) {
	case 1:
		p.SetState(715)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PythonParserAWAIT {
			{
				p.SetState(714)
				p.Match(PythonParserAWAIT)
			}

		}
		{
			p.SetState(717)
			p.Atom()
		}
		p.SetState(721)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 104, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(718)
					p.Trailer()
				}

			}
			p.SetState(723)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 104, p.GetParserRuleContext())
		}

	case 2:
		{
			p.SetState(724)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ExprContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((_la-55)&-(0x1f+1)) == 0 && ((1<<uint((_la-55)))&((1<<(PythonParserADD-55))|(1<<(PythonParserMINUS-55))|(1<<(PythonParserNOT_OP-55)))) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ExprContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(725)
			p.expr(7)
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(751)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 107, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(749)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 106, p.GetParserRuleContext()) {
			case 1:
				localctx = NewExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, PythonParserRULE_expr)
				p.SetState(728)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
				}
				{
					p.SetState(729)

					var _m = p.Match(PythonParserPOWER)

					localctx.(*ExprContext).op = _m
				}
				{
					p.SetState(730)
					p.expr(8)
				}

			case 2:
				localctx = NewExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, PythonParserRULE_expr)
				p.SetState(731)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
				}
				{
					p.SetState(732)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ExprContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(((_la-44)&-(0x1f+1)) == 0 && ((1<<uint((_la-44)))&((1<<(PythonParserSTAR-44))|(1<<(PythonParserDIV-44))|(1<<(PythonParserMOD-44))|(1<<(PythonParserIDIV-44))|(1<<(PythonParserAT-44)))) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ExprContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(733)
					p.expr(7)
				}

			case 3:
				localctx = NewExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, PythonParserRULE_expr)
				p.SetState(734)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
				}
				{
					p.SetState(735)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ExprContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == PythonParserADD || _la == PythonParserMINUS) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ExprContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(736)
					p.expr(6)
				}

			case 4:
				localctx = NewExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, PythonParserRULE_expr)
				p.SetState(737)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
				}
				{
					p.SetState(738)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ExprContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == PythonParserLEFT_SHIFT || _la == PythonParserRIGHT_SHIFT) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ExprContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(739)
					p.expr(5)
				}

			case 5:
				localctx = NewExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, PythonParserRULE_expr)
				p.SetState(740)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(741)

					var _m = p.Match(PythonParserAND_OP)

					localctx.(*ExprContext).op = _m
				}
				{
					p.SetState(742)
					p.expr(4)
				}

			case 6:
				localctx = NewExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, PythonParserRULE_expr)
				p.SetState(743)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(744)

					var _m = p.Match(PythonParserXOR)

					localctx.(*ExprContext).op = _m
				}
				{
					p.SetState(745)
					p.expr(3)
				}

			case 7:
				localctx = NewExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, PythonParserRULE_expr)
				p.SetState(746)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(747)

					var _m = p.Match(PythonParserOR_OP)

					localctx.(*ExprContext).op = _m
				}
				{
					p.SetState(748)
					p.expr(2)
				}

			}

		}
		p.SetState(753)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 107, p.GetParserRuleContext())
	}

	return localctx
}

// IAtomContext is an interface to support dynamic dispatch.
type IAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtomContext differentiates from other interfaces.
	IsAtomContext()
}

type AtomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomContext() *AtomContext {
	var p = new(AtomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_atom
	return p
}

func (*AtomContext) IsAtomContext() {}

func NewAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomContext {
	var p = new(AtomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_atom

	return p
}

func (s *AtomContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(PythonParserOPEN_PAREN, 0)
}

func (s *AtomContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(PythonParserCLOSE_PAREN, 0)
}

func (s *AtomContext) Yield_expr() IYield_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IYield_exprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IYield_exprContext)
}

func (s *AtomContext) Testlist_comp() ITestlist_compContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestlist_compContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestlist_compContext)
}

func (s *AtomContext) OPEN_BRACKET() antlr.TerminalNode {
	return s.GetToken(PythonParserOPEN_BRACKET, 0)
}

func (s *AtomContext) CLOSE_BRACKET() antlr.TerminalNode {
	return s.GetToken(PythonParserCLOSE_BRACKET, 0)
}

func (s *AtomContext) OPEN_BRACE() antlr.TerminalNode {
	return s.GetToken(PythonParserOPEN_BRACE, 0)
}

func (s *AtomContext) CLOSE_BRACE() antlr.TerminalNode {
	return s.GetToken(PythonParserCLOSE_BRACE, 0)
}

func (s *AtomContext) Dictorsetmaker() IDictorsetmakerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDictorsetmakerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDictorsetmakerContext)
}

func (s *AtomContext) AllREVERSE_QUOTE() []antlr.TerminalNode {
	return s.GetTokens(PythonParserREVERSE_QUOTE)
}

func (s *AtomContext) REVERSE_QUOTE(i int) antlr.TerminalNode {
	return s.GetToken(PythonParserREVERSE_QUOTE, i)
}

func (s *AtomContext) Testlist() ITestlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestlistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestlistContext)
}

func (s *AtomContext) COMMA() antlr.TerminalNode {
	return s.GetToken(PythonParserCOMMA, 0)
}

func (s *AtomContext) ELLIPSIS() antlr.TerminalNode {
	return s.GetToken(PythonParserELLIPSIS, 0)
}

func (s *AtomContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *AtomContext) PRINT() antlr.TerminalNode {
	return s.GetToken(PythonParserPRINT, 0)
}

func (s *AtomContext) EXEC() antlr.TerminalNode {
	return s.GetToken(PythonParserEXEC, 0)
}

func (s *AtomContext) Number() INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *AtomContext) MINUS() antlr.TerminalNode {
	return s.GetToken(PythonParserMINUS, 0)
}

func (s *AtomContext) NONE() antlr.TerminalNode {
	return s.GetToken(PythonParserNONE, 0)
}

func (s *AtomContext) AllSTRING() []antlr.TerminalNode {
	return s.GetTokens(PythonParserSTRING)
}

func (s *AtomContext) STRING(i int) antlr.TerminalNode {
	return s.GetToken(PythonParserSTRING, i)
}

func (s *AtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterAtom(s)
	}
}

func (s *AtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitAtom(s)
	}
}

func (p *PythonParser) Atom() (localctx IAtomContext) {
	localctx = NewAtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, PythonParserRULE_atom)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(791)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PythonParserOPEN_PAREN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(754)
			p.Match(PythonParserOPEN_PAREN)
		}
		p.SetState(757)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case PythonParserYIELD:
			{
				p.SetState(755)
				p.Yield_expr()
			}

		case PythonParserNONE, PythonParserLAMBDA, PythonParserNOT, PythonParserAWAIT, PythonParserPRINT, PythonParserEXEC, PythonParserTRUE, PythonParserFALSE, PythonParserELLIPSIS, PythonParserREVERSE_QUOTE, PythonParserSTAR, PythonParserADD, PythonParserMINUS, PythonParserNOT_OP, PythonParserSTRING, PythonParserDECIMAL_INTEGER, PythonParserOCT_INTEGER, PythonParserHEX_INTEGER, PythonParserBIN_INTEGER, PythonParserIMAG_NUMBER, PythonParserFLOAT_NUMBER, PythonParserOPEN_PAREN, PythonParserOPEN_BRACE, PythonParserOPEN_BRACKET, PythonParserNAME:
			{
				p.SetState(756)
				p.Testlist_comp()
			}

		case PythonParserCLOSE_PAREN:

		default:
		}
		{
			p.SetState(759)
			p.Match(PythonParserCLOSE_PAREN)
		}

	case PythonParserOPEN_BRACKET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(760)
			p.Match(PythonParserOPEN_BRACKET)
		}
		p.SetState(762)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PythonParserNONE)|(1<<PythonParserLAMBDA)|(1<<PythonParserNOT))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(PythonParserAWAIT-36))|(1<<(PythonParserPRINT-36))|(1<<(PythonParserEXEC-36))|(1<<(PythonParserTRUE-36))|(1<<(PythonParserFALSE-36))|(1<<(PythonParserELLIPSIS-36))|(1<<(PythonParserREVERSE_QUOTE-36))|(1<<(PythonParserSTAR-36))|(1<<(PythonParserADD-36))|(1<<(PythonParserMINUS-36))|(1<<(PythonParserNOT_OP-36)))) != 0) || (((_la-83)&-(0x1f+1)) == 0 && ((1<<uint((_la-83)))&((1<<(PythonParserSTRING-83))|(1<<(PythonParserDECIMAL_INTEGER-83))|(1<<(PythonParserOCT_INTEGER-83))|(1<<(PythonParserHEX_INTEGER-83))|(1<<(PythonParserBIN_INTEGER-83))|(1<<(PythonParserIMAG_NUMBER-83))|(1<<(PythonParserFLOAT_NUMBER-83))|(1<<(PythonParserOPEN_PAREN-83))|(1<<(PythonParserOPEN_BRACE-83))|(1<<(PythonParserOPEN_BRACKET-83))|(1<<(PythonParserNAME-83)))) != 0) {
			{
				p.SetState(761)
				p.Testlist_comp()
			}

		}
		{
			p.SetState(764)
			p.Match(PythonParserCLOSE_BRACKET)
		}

	case PythonParserOPEN_BRACE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(765)
			p.Match(PythonParserOPEN_BRACE)
		}
		p.SetState(767)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PythonParserNONE)|(1<<PythonParserLAMBDA)|(1<<PythonParserNOT))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(PythonParserAWAIT-36))|(1<<(PythonParserPRINT-36))|(1<<(PythonParserEXEC-36))|(1<<(PythonParserTRUE-36))|(1<<(PythonParserFALSE-36))|(1<<(PythonParserELLIPSIS-36))|(1<<(PythonParserREVERSE_QUOTE-36))|(1<<(PythonParserSTAR-36))|(1<<(PythonParserPOWER-36))|(1<<(PythonParserADD-36))|(1<<(PythonParserMINUS-36))|(1<<(PythonParserNOT_OP-36)))) != 0) || (((_la-83)&-(0x1f+1)) == 0 && ((1<<uint((_la-83)))&((1<<(PythonParserSTRING-83))|(1<<(PythonParserDECIMAL_INTEGER-83))|(1<<(PythonParserOCT_INTEGER-83))|(1<<(PythonParserHEX_INTEGER-83))|(1<<(PythonParserBIN_INTEGER-83))|(1<<(PythonParserIMAG_NUMBER-83))|(1<<(PythonParserFLOAT_NUMBER-83))|(1<<(PythonParserOPEN_PAREN-83))|(1<<(PythonParserOPEN_BRACE-83))|(1<<(PythonParserOPEN_BRACKET-83))|(1<<(PythonParserNAME-83)))) != 0) {
			{
				p.SetState(766)
				p.Dictorsetmaker()
			}

		}
		{
			p.SetState(769)
			p.Match(PythonParserCLOSE_BRACE)
		}

	case PythonParserREVERSE_QUOTE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(770)
			p.Match(PythonParserREVERSE_QUOTE)
		}
		{
			p.SetState(771)
			p.Testlist()
		}
		p.SetState(773)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PythonParserCOMMA {
			{
				p.SetState(772)
				p.Match(PythonParserCOMMA)
			}

		}
		{
			p.SetState(775)
			p.Match(PythonParserREVERSE_QUOTE)
		}

	case PythonParserELLIPSIS:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(777)
			p.Match(PythonParserELLIPSIS)
		}

	case PythonParserTRUE, PythonParserFALSE, PythonParserNAME:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(778)
			p.Name()
		}

	case PythonParserPRINT:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(779)
			p.Match(PythonParserPRINT)
		}

	case PythonParserEXEC:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(780)
			p.Match(PythonParserEXEC)
		}

	case PythonParserMINUS, PythonParserDECIMAL_INTEGER, PythonParserOCT_INTEGER, PythonParserHEX_INTEGER, PythonParserBIN_INTEGER, PythonParserIMAG_NUMBER, PythonParserFLOAT_NUMBER:
		p.EnterOuterAlt(localctx, 9)
		p.SetState(782)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PythonParserMINUS {
			{
				p.SetState(781)
				p.Match(PythonParserMINUS)
			}

		}
		{
			p.SetState(784)
			p.Number()
		}

	case PythonParserNONE:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(785)
			p.Match(PythonParserNONE)
		}

	case PythonParserSTRING:
		p.EnterOuterAlt(localctx, 11)
		p.SetState(787)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(786)
					p.Match(PythonParserSTRING)
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(789)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 113, p.GetParserRuleContext())
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDictorsetmakerContext is an interface to support dynamic dispatch.
type IDictorsetmakerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDictorsetmakerContext differentiates from other interfaces.
	IsDictorsetmakerContext()
}

type DictorsetmakerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDictorsetmakerContext() *DictorsetmakerContext {
	var p = new(DictorsetmakerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_dictorsetmaker
	return p
}

func (*DictorsetmakerContext) IsDictorsetmakerContext() {}

func NewDictorsetmakerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DictorsetmakerContext {
	var p = new(DictorsetmakerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_dictorsetmaker

	return p
}

func (s *DictorsetmakerContext) GetParser() antlr.Parser { return s.parser }

func (s *DictorsetmakerContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *DictorsetmakerContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *DictorsetmakerContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(PythonParserCOLON)
}

func (s *DictorsetmakerContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(PythonParserCOLON, i)
}

func (s *DictorsetmakerContext) AllPOWER() []antlr.TerminalNode {
	return s.GetTokens(PythonParserPOWER)
}

func (s *DictorsetmakerContext) POWER(i int) antlr.TerminalNode {
	return s.GetToken(PythonParserPOWER, i)
}

func (s *DictorsetmakerContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *DictorsetmakerContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *DictorsetmakerContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(PythonParserCOMMA)
}

func (s *DictorsetmakerContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(PythonParserCOMMA, i)
}

func (s *DictorsetmakerContext) Comp_for() IComp_forContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComp_forContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComp_forContext)
}

func (s *DictorsetmakerContext) Testlist_comp() ITestlist_compContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestlist_compContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestlist_compContext)
}

func (s *DictorsetmakerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DictorsetmakerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DictorsetmakerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterDictorsetmaker(s)
	}
}

func (s *DictorsetmakerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitDictorsetmaker(s)
	}
}

func (p *PythonParser) Dictorsetmaker() (localctx IDictorsetmakerContext) {
	localctx = NewDictorsetmakerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, PythonParserRULE_dictorsetmaker)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(824)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 119, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(799)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case PythonParserNONE, PythonParserLAMBDA, PythonParserNOT, PythonParserAWAIT, PythonParserPRINT, PythonParserEXEC, PythonParserTRUE, PythonParserFALSE, PythonParserELLIPSIS, PythonParserREVERSE_QUOTE, PythonParserADD, PythonParserMINUS, PythonParserNOT_OP, PythonParserSTRING, PythonParserDECIMAL_INTEGER, PythonParserOCT_INTEGER, PythonParserHEX_INTEGER, PythonParserBIN_INTEGER, PythonParserIMAG_NUMBER, PythonParserFLOAT_NUMBER, PythonParserOPEN_PAREN, PythonParserOPEN_BRACE, PythonParserOPEN_BRACKET, PythonParserNAME:
			{
				p.SetState(793)
				p.Test()
			}
			{
				p.SetState(794)
				p.Match(PythonParserCOLON)
			}
			{
				p.SetState(795)
				p.Test()
			}

		case PythonParserPOWER:
			{
				p.SetState(797)
				p.Match(PythonParserPOWER)
			}
			{
				p.SetState(798)
				p.expr(0)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		p.SetState(812)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 117, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(801)
					p.Match(PythonParserCOMMA)
				}
				p.SetState(808)
				p.GetErrorHandler().Sync(p)

				switch p.GetTokenStream().LA(1) {
				case PythonParserNONE, PythonParserLAMBDA, PythonParserNOT, PythonParserAWAIT, PythonParserPRINT, PythonParserEXEC, PythonParserTRUE, PythonParserFALSE, PythonParserELLIPSIS, PythonParserREVERSE_QUOTE, PythonParserADD, PythonParserMINUS, PythonParserNOT_OP, PythonParserSTRING, PythonParserDECIMAL_INTEGER, PythonParserOCT_INTEGER, PythonParserHEX_INTEGER, PythonParserBIN_INTEGER, PythonParserIMAG_NUMBER, PythonParserFLOAT_NUMBER, PythonParserOPEN_PAREN, PythonParserOPEN_BRACE, PythonParserOPEN_BRACKET, PythonParserNAME:
					{
						p.SetState(802)
						p.Test()
					}
					{
						p.SetState(803)
						p.Match(PythonParserCOLON)
					}
					{
						p.SetState(804)
						p.Test()
					}

				case PythonParserPOWER:
					{
						p.SetState(806)
						p.Match(PythonParserPOWER)
					}
					{
						p.SetState(807)
						p.expr(0)
					}

				default:
					panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				}

			}
			p.SetState(814)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 117, p.GetParserRuleContext())
		}
		p.SetState(816)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PythonParserCOMMA {
			{
				p.SetState(815)
				p.Match(PythonParserCOMMA)
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(818)
			p.Test()
		}
		{
			p.SetState(819)
			p.Match(PythonParserCOLON)
		}
		{
			p.SetState(820)
			p.Test()
		}
		{
			p.SetState(821)
			p.Comp_for()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(823)
			p.Testlist_comp()
		}

	}

	return localctx
}

// ITestlist_compContext is an interface to support dynamic dispatch.
type ITestlist_compContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTestlist_compContext differentiates from other interfaces.
	IsTestlist_compContext()
}

type Testlist_compContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTestlist_compContext() *Testlist_compContext {
	var p = new(Testlist_compContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_testlist_comp
	return p
}

func (*Testlist_compContext) IsTestlist_compContext() {}

func NewTestlist_compContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Testlist_compContext {
	var p = new(Testlist_compContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_testlist_comp

	return p
}

func (s *Testlist_compContext) GetParser() antlr.Parser { return s.parser }

func (s *Testlist_compContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *Testlist_compContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Testlist_compContext) AllStar_expr() []IStar_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStar_exprContext)(nil)).Elem())
	var tst = make([]IStar_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStar_exprContext)
		}
	}

	return tst
}

func (s *Testlist_compContext) Star_expr(i int) IStar_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStar_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStar_exprContext)
}

func (s *Testlist_compContext) Comp_for() IComp_forContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComp_forContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComp_forContext)
}

func (s *Testlist_compContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(PythonParserCOMMA)
}

func (s *Testlist_compContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(PythonParserCOMMA, i)
}

func (s *Testlist_compContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Testlist_compContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Testlist_compContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterTestlist_comp(s)
	}
}

func (s *Testlist_compContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitTestlist_comp(s)
	}
}

func (p *PythonParser) Testlist_comp() (localctx ITestlist_compContext) {
	localctx = NewTestlist_compContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, PythonParserRULE_testlist_comp)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(828)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PythonParserNONE, PythonParserLAMBDA, PythonParserNOT, PythonParserAWAIT, PythonParserPRINT, PythonParserEXEC, PythonParserTRUE, PythonParserFALSE, PythonParserELLIPSIS, PythonParserREVERSE_QUOTE, PythonParserADD, PythonParserMINUS, PythonParserNOT_OP, PythonParserSTRING, PythonParserDECIMAL_INTEGER, PythonParserOCT_INTEGER, PythonParserHEX_INTEGER, PythonParserBIN_INTEGER, PythonParserIMAG_NUMBER, PythonParserFLOAT_NUMBER, PythonParserOPEN_PAREN, PythonParserOPEN_BRACE, PythonParserOPEN_BRACKET, PythonParserNAME:
		{
			p.SetState(826)
			p.Test()
		}

	case PythonParserSTAR:
		{
			p.SetState(827)
			p.Star_expr()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(844)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PythonParserFOR:
		{
			p.SetState(830)
			p.Comp_for()
		}

	case PythonParserCOMMA, PythonParserCLOSE_PAREN, PythonParserCLOSE_BRACE, PythonParserCLOSE_BRACKET:
		p.SetState(838)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 122, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(831)
					p.Match(PythonParserCOMMA)
				}
				p.SetState(834)
				p.GetErrorHandler().Sync(p)

				switch p.GetTokenStream().LA(1) {
				case PythonParserNONE, PythonParserLAMBDA, PythonParserNOT, PythonParserAWAIT, PythonParserPRINT, PythonParserEXEC, PythonParserTRUE, PythonParserFALSE, PythonParserELLIPSIS, PythonParserREVERSE_QUOTE, PythonParserADD, PythonParserMINUS, PythonParserNOT_OP, PythonParserSTRING, PythonParserDECIMAL_INTEGER, PythonParserOCT_INTEGER, PythonParserHEX_INTEGER, PythonParserBIN_INTEGER, PythonParserIMAG_NUMBER, PythonParserFLOAT_NUMBER, PythonParserOPEN_PAREN, PythonParserOPEN_BRACE, PythonParserOPEN_BRACKET, PythonParserNAME:
					{
						p.SetState(832)
						p.Test()
					}

				case PythonParserSTAR:
					{
						p.SetState(833)
						p.Star_expr()
					}

				default:
					panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				}

			}
			p.SetState(840)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 122, p.GetParserRuleContext())
		}
		p.SetState(842)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PythonParserCOMMA {
			{
				p.SetState(841)
				p.Match(PythonParserCOMMA)
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITestlistContext is an interface to support dynamic dispatch.
type ITestlistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTestlistContext differentiates from other interfaces.
	IsTestlistContext()
}

type TestlistContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTestlistContext() *TestlistContext {
	var p = new(TestlistContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_testlist
	return p
}

func (*TestlistContext) IsTestlistContext() {}

func NewTestlistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TestlistContext {
	var p = new(TestlistContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_testlist

	return p
}

func (s *TestlistContext) GetParser() antlr.Parser { return s.parser }

func (s *TestlistContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *TestlistContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *TestlistContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(PythonParserCOMMA)
}

func (s *TestlistContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(PythonParserCOMMA, i)
}

func (s *TestlistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TestlistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TestlistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterTestlist(s)
	}
}

func (s *TestlistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitTestlist(s)
	}
}

func (p *PythonParser) Testlist() (localctx ITestlistContext) {
	localctx = NewTestlistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, PythonParserRULE_testlist)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(846)
		p.Test()
	}
	p.SetState(851)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 125, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(847)
				p.Match(PythonParserCOMMA)
			}
			{
				p.SetState(848)
				p.Test()
			}

		}
		p.SetState(853)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 125, p.GetParserRuleContext())
	}
	p.SetState(855)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 126, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(854)
			p.Match(PythonParserCOMMA)
		}

	}

	return localctx
}

// IDotted_nameContext is an interface to support dynamic dispatch.
type IDotted_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDotted_nameContext differentiates from other interfaces.
	IsDotted_nameContext()
}

type Dotted_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDotted_nameContext() *Dotted_nameContext {
	var p = new(Dotted_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_dotted_name
	return p
}

func (*Dotted_nameContext) IsDotted_nameContext() {}

func NewDotted_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dotted_nameContext {
	var p = new(Dotted_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_dotted_name

	return p
}

func (s *Dotted_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Dotted_nameContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Dotted_nameContext) Dotted_name() IDotted_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDotted_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDotted_nameContext)
}

func (s *Dotted_nameContext) DOT() antlr.TerminalNode {
	return s.GetToken(PythonParserDOT, 0)
}

func (s *Dotted_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dotted_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dotted_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterDotted_name(s)
	}
}

func (s *Dotted_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitDotted_name(s)
	}
}

func (p *PythonParser) Dotted_name() (localctx IDotted_nameContext) {
	return p.dotted_name(0)
}

func (p *PythonParser) dotted_name(_p int) (localctx IDotted_nameContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewDotted_nameContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IDotted_nameContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 92
	p.EnterRecursionRule(localctx, 92, PythonParserRULE_dotted_name, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(858)
		p.Name()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(865)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 127, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewDotted_nameContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, PythonParserRULE_dotted_name)
			p.SetState(860)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(861)
				p.Match(PythonParserDOT)
			}
			{
				p.SetState(862)
				p.Name()
			}

		}
		p.SetState(867)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 127, p.GetParserRuleContext())
	}

	return localctx
}

// INameContext is an interface to support dynamic dispatch.
type INameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNameContext differentiates from other interfaces.
	IsNameContext()
}

type NameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNameContext() *NameContext {
	var p = new(NameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_name
	return p
}

func (*NameContext) IsNameContext() {}

func NewNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NameContext {
	var p = new(NameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_name

	return p
}

func (s *NameContext) GetParser() antlr.Parser { return s.parser }

func (s *NameContext) NAME() antlr.TerminalNode {
	return s.GetToken(PythonParserNAME, 0)
}

func (s *NameContext) TRUE() antlr.TerminalNode {
	return s.GetToken(PythonParserTRUE, 0)
}

func (s *NameContext) FALSE() antlr.TerminalNode {
	return s.GetToken(PythonParserFALSE, 0)
}

func (s *NameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterName(s)
	}
}

func (s *NameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitName(s)
	}
}

func (p *PythonParser) Name() (localctx INameContext) {
	localctx = NewNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, PythonParserRULE_name)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(868)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PythonParserTRUE || _la == PythonParserFALSE || _la == PythonParserNAME) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// INumberContext is an interface to support dynamic dispatch.
type INumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumberContext differentiates from other interfaces.
	IsNumberContext()
}

type NumberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberContext() *NumberContext {
	var p = new(NumberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_number
	return p
}

func (*NumberContext) IsNumberContext() {}

func NewNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberContext {
	var p = new(NumberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_number

	return p
}

func (s *NumberContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberContext) Integer() IIntegerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerContext)
}

func (s *NumberContext) IMAG_NUMBER() antlr.TerminalNode {
	return s.GetToken(PythonParserIMAG_NUMBER, 0)
}

func (s *NumberContext) FLOAT_NUMBER() antlr.TerminalNode {
	return s.GetToken(PythonParserFLOAT_NUMBER, 0)
}

func (s *NumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterNumber(s)
	}
}

func (s *NumberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitNumber(s)
	}
}

func (p *PythonParser) Number() (localctx INumberContext) {
	localctx = NewNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, PythonParserRULE_number)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(873)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PythonParserDECIMAL_INTEGER, PythonParserOCT_INTEGER, PythonParserHEX_INTEGER, PythonParserBIN_INTEGER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(870)
			p.Integer()
		}

	case PythonParserIMAG_NUMBER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(871)
			p.Match(PythonParserIMAG_NUMBER)
		}

	case PythonParserFLOAT_NUMBER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(872)
			p.Match(PythonParserFLOAT_NUMBER)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIntegerContext is an interface to support dynamic dispatch.
type IIntegerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIntegerContext differentiates from other interfaces.
	IsIntegerContext()
}

type IntegerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntegerContext() *IntegerContext {
	var p = new(IntegerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_integer
	return p
}

func (*IntegerContext) IsIntegerContext() {}

func NewIntegerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntegerContext {
	var p = new(IntegerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_integer

	return p
}

func (s *IntegerContext) GetParser() antlr.Parser { return s.parser }

func (s *IntegerContext) DECIMAL_INTEGER() antlr.TerminalNode {
	return s.GetToken(PythonParserDECIMAL_INTEGER, 0)
}

func (s *IntegerContext) OCT_INTEGER() antlr.TerminalNode {
	return s.GetToken(PythonParserOCT_INTEGER, 0)
}

func (s *IntegerContext) HEX_INTEGER() antlr.TerminalNode {
	return s.GetToken(PythonParserHEX_INTEGER, 0)
}

func (s *IntegerContext) BIN_INTEGER() antlr.TerminalNode {
	return s.GetToken(PythonParserBIN_INTEGER, 0)
}

func (s *IntegerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntegerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterInteger(s)
	}
}

func (s *IntegerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitInteger(s)
	}
}

func (p *PythonParser) Integer() (localctx IIntegerContext) {
	localctx = NewIntegerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, PythonParserRULE_integer)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(875)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-84)&-(0x1f+1)) == 0 && ((1<<uint((_la-84)))&((1<<(PythonParserDECIMAL_INTEGER-84))|(1<<(PythonParserOCT_INTEGER-84))|(1<<(PythonParserHEX_INTEGER-84))|(1<<(PythonParserBIN_INTEGER-84)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IYield_exprContext is an interface to support dynamic dispatch.
type IYield_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsYield_exprContext differentiates from other interfaces.
	IsYield_exprContext()
}

type Yield_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYield_exprContext() *Yield_exprContext {
	var p = new(Yield_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_yield_expr
	return p
}

func (*Yield_exprContext) IsYield_exprContext() {}

func NewYield_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Yield_exprContext {
	var p = new(Yield_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_yield_expr

	return p
}

func (s *Yield_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Yield_exprContext) YIELD() antlr.TerminalNode {
	return s.GetToken(PythonParserYIELD, 0)
}

func (s *Yield_exprContext) Yield_arg() IYield_argContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IYield_argContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IYield_argContext)
}

func (s *Yield_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Yield_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Yield_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterYield_expr(s)
	}
}

func (s *Yield_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitYield_expr(s)
	}
}

func (p *PythonParser) Yield_expr() (localctx IYield_exprContext) {
	localctx = NewYield_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, PythonParserRULE_yield_expr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(877)
		p.Match(PythonParserYIELD)
	}
	p.SetState(879)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PythonParserFROM)|(1<<PythonParserNONE)|(1<<PythonParserLAMBDA)|(1<<PythonParserNOT))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(PythonParserAWAIT-36))|(1<<(PythonParserPRINT-36))|(1<<(PythonParserEXEC-36))|(1<<(PythonParserTRUE-36))|(1<<(PythonParserFALSE-36))|(1<<(PythonParserELLIPSIS-36))|(1<<(PythonParserREVERSE_QUOTE-36))|(1<<(PythonParserADD-36))|(1<<(PythonParserMINUS-36))|(1<<(PythonParserNOT_OP-36)))) != 0) || (((_la-83)&-(0x1f+1)) == 0 && ((1<<uint((_la-83)))&((1<<(PythonParserSTRING-83))|(1<<(PythonParserDECIMAL_INTEGER-83))|(1<<(PythonParserOCT_INTEGER-83))|(1<<(PythonParserHEX_INTEGER-83))|(1<<(PythonParserBIN_INTEGER-83))|(1<<(PythonParserIMAG_NUMBER-83))|(1<<(PythonParserFLOAT_NUMBER-83))|(1<<(PythonParserOPEN_PAREN-83))|(1<<(PythonParserOPEN_BRACE-83))|(1<<(PythonParserOPEN_BRACKET-83))|(1<<(PythonParserNAME-83)))) != 0) {
		{
			p.SetState(878)
			p.Yield_arg()
		}

	}

	return localctx
}

// IYield_argContext is an interface to support dynamic dispatch.
type IYield_argContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsYield_argContext differentiates from other interfaces.
	IsYield_argContext()
}

type Yield_argContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYield_argContext() *Yield_argContext {
	var p = new(Yield_argContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_yield_arg
	return p
}

func (*Yield_argContext) IsYield_argContext() {}

func NewYield_argContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Yield_argContext {
	var p = new(Yield_argContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_yield_arg

	return p
}

func (s *Yield_argContext) GetParser() antlr.Parser { return s.parser }

func (s *Yield_argContext) FROM() antlr.TerminalNode {
	return s.GetToken(PythonParserFROM, 0)
}

func (s *Yield_argContext) Test() ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Yield_argContext) Testlist() ITestlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestlistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestlistContext)
}

func (s *Yield_argContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Yield_argContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Yield_argContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterYield_arg(s)
	}
}

func (s *Yield_argContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitYield_arg(s)
	}
}

func (p *PythonParser) Yield_arg() (localctx IYield_argContext) {
	localctx = NewYield_argContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, PythonParserRULE_yield_arg)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(884)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PythonParserFROM:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(881)
			p.Match(PythonParserFROM)
		}
		{
			p.SetState(882)
			p.Test()
		}

	case PythonParserNONE, PythonParserLAMBDA, PythonParserNOT, PythonParserAWAIT, PythonParserPRINT, PythonParserEXEC, PythonParserTRUE, PythonParserFALSE, PythonParserELLIPSIS, PythonParserREVERSE_QUOTE, PythonParserADD, PythonParserMINUS, PythonParserNOT_OP, PythonParserSTRING, PythonParserDECIMAL_INTEGER, PythonParserOCT_INTEGER, PythonParserHEX_INTEGER, PythonParserBIN_INTEGER, PythonParserIMAG_NUMBER, PythonParserFLOAT_NUMBER, PythonParserOPEN_PAREN, PythonParserOPEN_BRACE, PythonParserOPEN_BRACKET, PythonParserNAME:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(883)
			p.Testlist()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITrailerContext is an interface to support dynamic dispatch.
type ITrailerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTrailerContext differentiates from other interfaces.
	IsTrailerContext()
}

type TrailerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTrailerContext() *TrailerContext {
	var p = new(TrailerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_trailer
	return p
}

func (*TrailerContext) IsTrailerContext() {}

func NewTrailerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TrailerContext {
	var p = new(TrailerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_trailer

	return p
}

func (s *TrailerContext) GetParser() antlr.Parser { return s.parser }

func (s *TrailerContext) DOT() antlr.TerminalNode {
	return s.GetToken(PythonParserDOT, 0)
}

func (s *TrailerContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *TrailerContext) Arguments() IArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *TrailerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TrailerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TrailerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterTrailer(s)
	}
}

func (s *TrailerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitTrailer(s)
	}
}

func (p *PythonParser) Trailer() (localctx ITrailerContext) {
	localctx = NewTrailerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, PythonParserRULE_trailer)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(892)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PythonParserDOT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(886)
			p.Match(PythonParserDOT)
		}
		{
			p.SetState(887)
			p.Name()
		}
		p.SetState(889)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 131, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(888)
				p.Arguments()
			}

		}

	case PythonParserOPEN_PAREN, PythonParserOPEN_BRACKET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(891)
			p.Arguments()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IArgumentsContext is an interface to support dynamic dispatch.
type IArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentsContext differentiates from other interfaces.
	IsArgumentsContext()
}

type ArgumentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentsContext() *ArgumentsContext {
	var p = new(ArgumentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_arguments
	return p
}

func (*ArgumentsContext) IsArgumentsContext() {}

func NewArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentsContext {
	var p = new(ArgumentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_arguments

	return p
}

func (s *ArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentsContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(PythonParserOPEN_PAREN, 0)
}

func (s *ArgumentsContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(PythonParserCLOSE_PAREN, 0)
}

func (s *ArgumentsContext) Arglist() IArglistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArglistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArglistContext)
}

func (s *ArgumentsContext) OPEN_BRACKET() antlr.TerminalNode {
	return s.GetToken(PythonParserOPEN_BRACKET, 0)
}

func (s *ArgumentsContext) Subscriptlist() ISubscriptlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubscriptlistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubscriptlistContext)
}

func (s *ArgumentsContext) CLOSE_BRACKET() antlr.TerminalNode {
	return s.GetToken(PythonParserCLOSE_BRACKET, 0)
}

func (s *ArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterArguments(s)
	}
}

func (s *ArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitArguments(s)
	}
}

func (p *PythonParser) Arguments() (localctx IArgumentsContext) {
	localctx = NewArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, PythonParserRULE_arguments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(903)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PythonParserOPEN_PAREN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(894)
			p.Match(PythonParserOPEN_PAREN)
		}
		p.SetState(896)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PythonParserNONE)|(1<<PythonParserLAMBDA)|(1<<PythonParserNOT))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(PythonParserAWAIT-36))|(1<<(PythonParserPRINT-36))|(1<<(PythonParserEXEC-36))|(1<<(PythonParserTRUE-36))|(1<<(PythonParserFALSE-36))|(1<<(PythonParserELLIPSIS-36))|(1<<(PythonParserREVERSE_QUOTE-36))|(1<<(PythonParserSTAR-36))|(1<<(PythonParserPOWER-36))|(1<<(PythonParserADD-36))|(1<<(PythonParserMINUS-36))|(1<<(PythonParserNOT_OP-36)))) != 0) || (((_la-83)&-(0x1f+1)) == 0 && ((1<<uint((_la-83)))&((1<<(PythonParserSTRING-83))|(1<<(PythonParserDECIMAL_INTEGER-83))|(1<<(PythonParserOCT_INTEGER-83))|(1<<(PythonParserHEX_INTEGER-83))|(1<<(PythonParserBIN_INTEGER-83))|(1<<(PythonParserIMAG_NUMBER-83))|(1<<(PythonParserFLOAT_NUMBER-83))|(1<<(PythonParserOPEN_PAREN-83))|(1<<(PythonParserOPEN_BRACE-83))|(1<<(PythonParserOPEN_BRACKET-83))|(1<<(PythonParserNAME-83)))) != 0) {
			{
				p.SetState(895)
				p.Arglist()
			}

		}
		{
			p.SetState(898)
			p.Match(PythonParserCLOSE_PAREN)
		}

	case PythonParserOPEN_BRACKET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(899)
			p.Match(PythonParserOPEN_BRACKET)
		}
		{
			p.SetState(900)
			p.Subscriptlist()
		}
		{
			p.SetState(901)
			p.Match(PythonParserCLOSE_BRACKET)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IArglistContext is an interface to support dynamic dispatch.
type IArglistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArglistContext differentiates from other interfaces.
	IsArglistContext()
}

type ArglistContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArglistContext() *ArglistContext {
	var p = new(ArglistContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_arglist
	return p
}

func (*ArglistContext) IsArglistContext() {}

func NewArglistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArglistContext {
	var p = new(ArglistContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_arglist

	return p
}

func (s *ArglistContext) GetParser() antlr.Parser { return s.parser }

func (s *ArglistContext) AllArgument() []IArgumentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArgumentContext)(nil)).Elem())
	var tst = make([]IArgumentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArgumentContext)
		}
	}

	return tst
}

func (s *ArglistContext) Argument(i int) IArgumentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArgumentContext)
}

func (s *ArglistContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(PythonParserCOMMA)
}

func (s *ArglistContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(PythonParserCOMMA, i)
}

func (s *ArglistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArglistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArglistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterArglist(s)
	}
}

func (s *ArglistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitArglist(s)
	}
}

func (p *PythonParser) Arglist() (localctx IArglistContext) {
	localctx = NewArglistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, PythonParserRULE_arglist)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(905)
		p.Argument()
	}
	p.SetState(910)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 135, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(906)
				p.Match(PythonParserCOMMA)
			}
			{
				p.SetState(907)
				p.Argument()
			}

		}
		p.SetState(912)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 135, p.GetParserRuleContext())
	}
	p.SetState(914)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PythonParserCOMMA {
		{
			p.SetState(913)
			p.Match(PythonParserCOMMA)
		}

	}

	return localctx
}

// IArgumentContext is an interface to support dynamic dispatch.
type IArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentContext differentiates from other interfaces.
	IsArgumentContext()
}

type ArgumentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentContext() *ArgumentContext {
	var p = new(ArgumentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_argument
	return p
}

func (*ArgumentContext) IsArgumentContext() {}

func NewArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentContext {
	var p = new(ArgumentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_argument

	return p
}

func (s *ArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *ArgumentContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *ArgumentContext) Comp_for() IComp_forContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComp_forContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComp_forContext)
}

func (s *ArgumentContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(PythonParserASSIGN, 0)
}

func (s *ArgumentContext) POWER() antlr.TerminalNode {
	return s.GetToken(PythonParserPOWER, 0)
}

func (s *ArgumentContext) STAR() antlr.TerminalNode {
	return s.GetToken(PythonParserSTAR, 0)
}

func (s *ArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterArgument(s)
	}
}

func (s *ArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitArgument(s)
	}
}

func (p *PythonParser) Argument() (localctx IArgumentContext) {
	localctx = NewArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, PythonParserRULE_argument)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(924)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PythonParserNONE, PythonParserLAMBDA, PythonParserNOT, PythonParserAWAIT, PythonParserPRINT, PythonParserEXEC, PythonParserTRUE, PythonParserFALSE, PythonParserELLIPSIS, PythonParserREVERSE_QUOTE, PythonParserADD, PythonParserMINUS, PythonParserNOT_OP, PythonParserSTRING, PythonParserDECIMAL_INTEGER, PythonParserOCT_INTEGER, PythonParserHEX_INTEGER, PythonParserBIN_INTEGER, PythonParserIMAG_NUMBER, PythonParserFLOAT_NUMBER, PythonParserOPEN_PAREN, PythonParserOPEN_BRACE, PythonParserOPEN_BRACKET, PythonParserNAME:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(916)
			p.Test()
		}
		p.SetState(920)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case PythonParserFOR:
			{
				p.SetState(917)
				p.Comp_for()
			}

		case PythonParserASSIGN:
			{
				p.SetState(918)
				p.Match(PythonParserASSIGN)
			}
			{
				p.SetState(919)
				p.Test()
			}

		case PythonParserCOMMA, PythonParserCLOSE_PAREN:

		default:
		}

	case PythonParserSTAR, PythonParserPOWER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(922)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PythonParserSTAR || _la == PythonParserPOWER) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(923)
			p.Test()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISubscriptlistContext is an interface to support dynamic dispatch.
type ISubscriptlistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubscriptlistContext differentiates from other interfaces.
	IsSubscriptlistContext()
}

type SubscriptlistContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubscriptlistContext() *SubscriptlistContext {
	var p = new(SubscriptlistContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_subscriptlist
	return p
}

func (*SubscriptlistContext) IsSubscriptlistContext() {}

func NewSubscriptlistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubscriptlistContext {
	var p = new(SubscriptlistContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_subscriptlist

	return p
}

func (s *SubscriptlistContext) GetParser() antlr.Parser { return s.parser }

func (s *SubscriptlistContext) AllSubscript() []ISubscriptContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISubscriptContext)(nil)).Elem())
	var tst = make([]ISubscriptContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISubscriptContext)
		}
	}

	return tst
}

func (s *SubscriptlistContext) Subscript(i int) ISubscriptContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubscriptContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISubscriptContext)
}

func (s *SubscriptlistContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(PythonParserCOMMA)
}

func (s *SubscriptlistContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(PythonParserCOMMA, i)
}

func (s *SubscriptlistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubscriptlistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubscriptlistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterSubscriptlist(s)
	}
}

func (s *SubscriptlistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitSubscriptlist(s)
	}
}

func (p *PythonParser) Subscriptlist() (localctx ISubscriptlistContext) {
	localctx = NewSubscriptlistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, PythonParserRULE_subscriptlist)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(926)
		p.Subscript()
	}
	p.SetState(931)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 139, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(927)
				p.Match(PythonParserCOMMA)
			}
			{
				p.SetState(928)
				p.Subscript()
			}

		}
		p.SetState(933)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 139, p.GetParserRuleContext())
	}
	p.SetState(935)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PythonParserCOMMA {
		{
			p.SetState(934)
			p.Match(PythonParserCOMMA)
		}

	}

	return localctx
}

// ISubscriptContext is an interface to support dynamic dispatch.
type ISubscriptContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubscriptContext differentiates from other interfaces.
	IsSubscriptContext()
}

type SubscriptContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubscriptContext() *SubscriptContext {
	var p = new(SubscriptContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_subscript
	return p
}

func (*SubscriptContext) IsSubscriptContext() {}

func NewSubscriptContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubscriptContext {
	var p = new(SubscriptContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_subscript

	return p
}

func (s *SubscriptContext) GetParser() antlr.Parser { return s.parser }

func (s *SubscriptContext) ELLIPSIS() antlr.TerminalNode {
	return s.GetToken(PythonParserELLIPSIS, 0)
}

func (s *SubscriptContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *SubscriptContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *SubscriptContext) COLON() antlr.TerminalNode {
	return s.GetToken(PythonParserCOLON, 0)
}

func (s *SubscriptContext) Sliceop() ISliceopContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISliceopContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISliceopContext)
}

func (s *SubscriptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubscriptContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubscriptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterSubscript(s)
	}
}

func (s *SubscriptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitSubscript(s)
	}
}

func (p *PythonParser) Subscript() (localctx ISubscriptContext) {
	localctx = NewSubscriptContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, PythonParserRULE_subscript)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(955)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 146, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(937)
			p.Match(PythonParserELLIPSIS)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(938)
			p.Test()
		}
		p.SetState(946)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PythonParserCOLON {
			{
				p.SetState(939)
				p.Match(PythonParserCOLON)
			}
			p.SetState(941)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PythonParserNONE)|(1<<PythonParserLAMBDA)|(1<<PythonParserNOT))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(PythonParserAWAIT-36))|(1<<(PythonParserPRINT-36))|(1<<(PythonParserEXEC-36))|(1<<(PythonParserTRUE-36))|(1<<(PythonParserFALSE-36))|(1<<(PythonParserELLIPSIS-36))|(1<<(PythonParserREVERSE_QUOTE-36))|(1<<(PythonParserADD-36))|(1<<(PythonParserMINUS-36))|(1<<(PythonParserNOT_OP-36)))) != 0) || (((_la-83)&-(0x1f+1)) == 0 && ((1<<uint((_la-83)))&((1<<(PythonParserSTRING-83))|(1<<(PythonParserDECIMAL_INTEGER-83))|(1<<(PythonParserOCT_INTEGER-83))|(1<<(PythonParserHEX_INTEGER-83))|(1<<(PythonParserBIN_INTEGER-83))|(1<<(PythonParserIMAG_NUMBER-83))|(1<<(PythonParserFLOAT_NUMBER-83))|(1<<(PythonParserOPEN_PAREN-83))|(1<<(PythonParserOPEN_BRACE-83))|(1<<(PythonParserOPEN_BRACKET-83))|(1<<(PythonParserNAME-83)))) != 0) {
				{
					p.SetState(940)
					p.Test()
				}

			}
			p.SetState(944)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == PythonParserCOLON {
				{
					p.SetState(943)
					p.Sliceop()
				}

			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(948)
			p.Match(PythonParserCOLON)
		}
		p.SetState(950)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PythonParserNONE)|(1<<PythonParserLAMBDA)|(1<<PythonParserNOT))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(PythonParserAWAIT-36))|(1<<(PythonParserPRINT-36))|(1<<(PythonParserEXEC-36))|(1<<(PythonParserTRUE-36))|(1<<(PythonParserFALSE-36))|(1<<(PythonParserELLIPSIS-36))|(1<<(PythonParserREVERSE_QUOTE-36))|(1<<(PythonParserADD-36))|(1<<(PythonParserMINUS-36))|(1<<(PythonParserNOT_OP-36)))) != 0) || (((_la-83)&-(0x1f+1)) == 0 && ((1<<uint((_la-83)))&((1<<(PythonParserSTRING-83))|(1<<(PythonParserDECIMAL_INTEGER-83))|(1<<(PythonParserOCT_INTEGER-83))|(1<<(PythonParserHEX_INTEGER-83))|(1<<(PythonParserBIN_INTEGER-83))|(1<<(PythonParserIMAG_NUMBER-83))|(1<<(PythonParserFLOAT_NUMBER-83))|(1<<(PythonParserOPEN_PAREN-83))|(1<<(PythonParserOPEN_BRACE-83))|(1<<(PythonParserOPEN_BRACKET-83))|(1<<(PythonParserNAME-83)))) != 0) {
			{
				p.SetState(949)
				p.Test()
			}

		}
		p.SetState(953)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PythonParserCOLON {
			{
				p.SetState(952)
				p.Sliceop()
			}

		}

	}

	return localctx
}

// ISliceopContext is an interface to support dynamic dispatch.
type ISliceopContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSliceopContext differentiates from other interfaces.
	IsSliceopContext()
}

type SliceopContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySliceopContext() *SliceopContext {
	var p = new(SliceopContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_sliceop
	return p
}

func (*SliceopContext) IsSliceopContext() {}

func NewSliceopContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SliceopContext {
	var p = new(SliceopContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_sliceop

	return p
}

func (s *SliceopContext) GetParser() antlr.Parser { return s.parser }

func (s *SliceopContext) COLON() antlr.TerminalNode {
	return s.GetToken(PythonParserCOLON, 0)
}

func (s *SliceopContext) Test() ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *SliceopContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SliceopContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SliceopContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterSliceop(s)
	}
}

func (s *SliceopContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitSliceop(s)
	}
}

func (p *PythonParser) Sliceop() (localctx ISliceopContext) {
	localctx = NewSliceopContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, PythonParserRULE_sliceop)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(957)
		p.Match(PythonParserCOLON)
	}
	p.SetState(959)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PythonParserNONE)|(1<<PythonParserLAMBDA)|(1<<PythonParserNOT))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(PythonParserAWAIT-36))|(1<<(PythonParserPRINT-36))|(1<<(PythonParserEXEC-36))|(1<<(PythonParserTRUE-36))|(1<<(PythonParserFALSE-36))|(1<<(PythonParserELLIPSIS-36))|(1<<(PythonParserREVERSE_QUOTE-36))|(1<<(PythonParserADD-36))|(1<<(PythonParserMINUS-36))|(1<<(PythonParserNOT_OP-36)))) != 0) || (((_la-83)&-(0x1f+1)) == 0 && ((1<<uint((_la-83)))&((1<<(PythonParserSTRING-83))|(1<<(PythonParserDECIMAL_INTEGER-83))|(1<<(PythonParserOCT_INTEGER-83))|(1<<(PythonParserHEX_INTEGER-83))|(1<<(PythonParserBIN_INTEGER-83))|(1<<(PythonParserIMAG_NUMBER-83))|(1<<(PythonParserFLOAT_NUMBER-83))|(1<<(PythonParserOPEN_PAREN-83))|(1<<(PythonParserOPEN_BRACE-83))|(1<<(PythonParserOPEN_BRACKET-83))|(1<<(PythonParserNAME-83)))) != 0) {
		{
			p.SetState(958)
			p.Test()
		}

	}

	return localctx
}

// IComp_forContext is an interface to support dynamic dispatch.
type IComp_forContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComp_forContext differentiates from other interfaces.
	IsComp_forContext()
}

type Comp_forContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComp_forContext() *Comp_forContext {
	var p = new(Comp_forContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_comp_for
	return p
}

func (*Comp_forContext) IsComp_forContext() {}

func NewComp_forContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comp_forContext {
	var p = new(Comp_forContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_comp_for

	return p
}

func (s *Comp_forContext) GetParser() antlr.Parser { return s.parser }

func (s *Comp_forContext) FOR() antlr.TerminalNode {
	return s.GetToken(PythonParserFOR, 0)
}

func (s *Comp_forContext) Exprlist() IExprlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprlistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprlistContext)
}

func (s *Comp_forContext) IN() antlr.TerminalNode {
	return s.GetToken(PythonParserIN, 0)
}

func (s *Comp_forContext) Logical_test() ILogical_testContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILogical_testContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILogical_testContext)
}

func (s *Comp_forContext) Comp_iter() IComp_iterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComp_iterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComp_iterContext)
}

func (s *Comp_forContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comp_forContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comp_forContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterComp_for(s)
	}
}

func (s *Comp_forContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitComp_for(s)
	}
}

func (p *PythonParser) Comp_for() (localctx IComp_forContext) {
	localctx = NewComp_forContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, PythonParserRULE_comp_for)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(961)
		p.Match(PythonParserFOR)
	}
	{
		p.SetState(962)
		p.Exprlist()
	}
	{
		p.SetState(963)
		p.Match(PythonParserIN)
	}
	{
		p.SetState(964)
		p.logical_test(0)
	}
	p.SetState(966)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PythonParserIF || _la == PythonParserFOR {
		{
			p.SetState(965)
			p.Comp_iter()
		}

	}

	return localctx
}

// IComp_iterContext is an interface to support dynamic dispatch.
type IComp_iterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComp_iterContext differentiates from other interfaces.
	IsComp_iterContext()
}

type Comp_iterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComp_iterContext() *Comp_iterContext {
	var p = new(Comp_iterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PythonParserRULE_comp_iter
	return p
}

func (*Comp_iterContext) IsComp_iterContext() {}

func NewComp_iterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comp_iterContext {
	var p = new(Comp_iterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PythonParserRULE_comp_iter

	return p
}

func (s *Comp_iterContext) GetParser() antlr.Parser { return s.parser }

func (s *Comp_iterContext) Comp_for() IComp_forContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComp_forContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComp_forContext)
}

func (s *Comp_iterContext) IF() antlr.TerminalNode {
	return s.GetToken(PythonParserIF, 0)
}

func (s *Comp_iterContext) Test() ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Comp_iterContext) Comp_iter() IComp_iterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComp_iterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComp_iterContext)
}

func (s *Comp_iterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comp_iterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comp_iterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.EnterComp_iter(s)
	}
}

func (s *Comp_iterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PythonParserListener); ok {
		listenerT.ExitComp_iter(s)
	}
}

func (p *PythonParser) Comp_iter() (localctx IComp_iterContext) {
	localctx = NewComp_iterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, PythonParserRULE_comp_iter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(974)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PythonParserFOR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(968)
			p.Comp_for()
		}

	case PythonParserIF:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(969)
			p.Match(PythonParserIF)
		}
		{
			p.SetState(970)
			p.Test()
		}
		p.SetState(972)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PythonParserIF || _la == PythonParserFOR {
			{
				p.SetState(971)
				p.Comp_iter()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

func (p *PythonParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 12:
		var t *Except_clauseContext = nil
		if localctx != nil {
			t = localctx.(*Except_clauseContext)
		}
		return p.Except_clause_Sempred(t, predIndex)

	case 22:
		var t *Small_stmtContext = nil
		if localctx != nil {
			t = localctx.(*Small_stmtContext)
		}
		return p.Small_stmt_Sempred(t, predIndex)

	case 27:
		var t *Assign_partContext = nil
		if localctx != nil {
			t = localctx.(*Assign_partContext)
		}
		return p.Assign_part_Sempred(t, predIndex)

	case 39:
		var t *Logical_testContext = nil
		if localctx != nil {
			t = localctx.(*Logical_testContext)
		}
		return p.Logical_test_Sempred(t, predIndex)

	case 40:
		var t *ComparisonContext = nil
		if localctx != nil {
			t = localctx.(*ComparisonContext)
		}
		return p.Comparison_Sempred(t, predIndex)

	case 41:
		var t *ExprContext = nil
		if localctx != nil {
			t = localctx.(*ExprContext)
		}
		return p.Expr_Sempred(t, predIndex)

	case 46:
		var t *Dotted_nameContext = nil
		if localctx != nil {
			t = localctx.(*Dotted_nameContext)
		}
		return p.Dotted_name_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *PythonParser) Except_clause_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.CheckVersion(2)

	case 1:
		return p.CheckVersion(3)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PythonParser) Small_stmt_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 2:
		return p.CheckVersion(2)

	case 3:
		return p.CheckVersion(2)

	case 4:
		return p.CheckVersion(3)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PythonParser) Assign_part_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 5:
		return p.CheckVersion(3)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PythonParser) Logical_test_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 6:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PythonParser) Comparison_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 8:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PythonParser) Expr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 9:
		return p.Precpred(p.GetParserRuleContext(), 8)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 13:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 14:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 15:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PythonParser) Dotted_name_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 16:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
